/*
 * generated by Xtext 2.13.0
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.myDsl.ArgumentExpressionListLinhaAction;
import org.xtext.example.mydsl.myDsl.DeclarationListLinhaAction;
import org.xtext.example.mydsl.myDsl.DesignatorListLinhaAction;
import org.xtext.example.mydsl.myDsl.DirectAbstractDeclarratorLinhaAction;
import org.xtext.example.mydsl.myDsl.EnumeratorListLinhaAction;
import org.xtext.example.mydsl.myDsl.GenericAssocListLinhaAction;
import org.xtext.example.mydsl.myDsl.IdentifierListLinhaAction;
import org.xtext.example.mydsl.myDsl.InitDecclaratorListLinhaAction;
import org.xtext.example.mydsl.myDsl.InitializerListLinhaAction;
import org.xtext.example.mydsl.myDsl.Model;
import org.xtext.example.mydsl.myDsl.MyDslPackage;
import org.xtext.example.mydsl.myDsl.PlusPlus;
import org.xtext.example.mydsl.myDsl.PostFixEmpryParams;
import org.xtext.example.mydsl.myDsl.PostfixExpressionLinhaAction;
import org.xtext.example.mydsl.myDsl.StructDeclarationListLinhaAction;
import org.xtext.example.mydsl.myDsl.StructDeclaratorListLinhaAction;
import org.xtext.example.mydsl.myDsl.StructOrUnionSpecifierComplementAction;
import org.xtext.example.mydsl.myDsl.TranlationUnitLinhaAction;
import org.xtext.example.mydsl.myDsl.TypeQualifierListLinhaAtion;
import org.xtext.example.mydsl.myDsl.abstract_declarator;
import org.xtext.example.mydsl.myDsl.additive_expression;
import org.xtext.example.mydsl.myDsl.additive_expression_complement;
import org.xtext.example.mydsl.myDsl.additive_expression_linha;
import org.xtext.example.mydsl.myDsl.alignment_specifier;
import org.xtext.example.mydsl.myDsl.and_expression;
import org.xtext.example.mydsl.myDsl.and_expression_linha;
import org.xtext.example.mydsl.myDsl.argument_expression_list;
import org.xtext.example.mydsl.myDsl.assignment_expression;
import org.xtext.example.mydsl.myDsl.atomic_type_specifier;
import org.xtext.example.mydsl.myDsl.block_item;
import org.xtext.example.mydsl.myDsl.block_item_list;
import org.xtext.example.mydsl.myDsl.block_item_list_linha;
import org.xtext.example.mydsl.myDsl.cast_expression;
import org.xtext.example.mydsl.myDsl.compound_statement;
import org.xtext.example.mydsl.myDsl.conditional_expression;
import org.xtext.example.mydsl.myDsl.conditional_expression_linha;
import org.xtext.example.mydsl.myDsl.constant;
import org.xtext.example.mydsl.myDsl.constant_expression;
import org.xtext.example.mydsl.myDsl.declaration;
import org.xtext.example.mydsl.myDsl.declaration_list;
import org.xtext.example.mydsl.myDsl.declaration_specifiers;
import org.xtext.example.mydsl.myDsl.declarator;
import org.xtext.example.mydsl.myDsl.designation;
import org.xtext.example.mydsl.myDsl.designator;
import org.xtext.example.mydsl.myDsl.designator_list;
import org.xtext.example.mydsl.myDsl.direct_abstract_declarator;
import org.xtext.example.mydsl.myDsl.direct_abstract_declarator_complement;
import org.xtext.example.mydsl.myDsl.direct_declarator;
import org.xtext.example.mydsl.myDsl.direct_declarator_complemento;
import org.xtext.example.mydsl.myDsl.direct_declarator_linha;
import org.xtext.example.mydsl.myDsl.enum_specifier;
import org.xtext.example.mydsl.myDsl.enumeration_constant;
import org.xtext.example.mydsl.myDsl.enumerator;
import org.xtext.example.mydsl.myDsl.enumerator_list;
import org.xtext.example.mydsl.myDsl.equality_expression;
import org.xtext.example.mydsl.myDsl.equality_expression_complement;
import org.xtext.example.mydsl.myDsl.equality_expression_linha;
import org.xtext.example.mydsl.myDsl.exclusive_or_expression;
import org.xtext.example.mydsl.myDsl.exclusive_or_expression_linha;
import org.xtext.example.mydsl.myDsl.expression;
import org.xtext.example.mydsl.myDsl.expression_linha;
import org.xtext.example.mydsl.myDsl.expression_statement;
import org.xtext.example.mydsl.myDsl.external_declaration;
import org.xtext.example.mydsl.myDsl.function_definition;
import org.xtext.example.mydsl.myDsl.generic_assoc_list;
import org.xtext.example.mydsl.myDsl.generic_association;
import org.xtext.example.mydsl.myDsl.generic_selection;
import org.xtext.example.mydsl.myDsl.identifier_list;
import org.xtext.example.mydsl.myDsl.inclusive_or_expression;
import org.xtext.example.mydsl.myDsl.inclusive_or_expression_linha;
import org.xtext.example.mydsl.myDsl.init_declarator;
import org.xtext.example.mydsl.myDsl.init_declarator_list;
import org.xtext.example.mydsl.myDsl.initializer;
import org.xtext.example.mydsl.myDsl.initializer_list;
import org.xtext.example.mydsl.myDsl.initializer_list_complement;
import org.xtext.example.mydsl.myDsl.iteration_statement;
import org.xtext.example.mydsl.myDsl.jump_statement;
import org.xtext.example.mydsl.myDsl.labeled_statement;
import org.xtext.example.mydsl.myDsl.logical_and_expression;
import org.xtext.example.mydsl.myDsl.logical_and_expression_linha;
import org.xtext.example.mydsl.myDsl.logical_or_expression;
import org.xtext.example.mydsl.myDsl.logical_or_expression_linha;
import org.xtext.example.mydsl.myDsl.multiplicative_expression;
import org.xtext.example.mydsl.myDsl.multiplicative_expression_complement;
import org.xtext.example.mydsl.myDsl.multiplicative_expression_linha;
import org.xtext.example.mydsl.myDsl.parameter_declaration;
import org.xtext.example.mydsl.myDsl.parameter_list_linha;
import org.xtext.example.mydsl.myDsl.parameter_lista;
import org.xtext.example.mydsl.myDsl.parameter_type_list;
import org.xtext.example.mydsl.myDsl.pointer;
import org.xtext.example.mydsl.myDsl.postfix_expression;
import org.xtext.example.mydsl.myDsl.postfix_expression_complement;
import org.xtext.example.mydsl.myDsl.primary_expression;
import org.xtext.example.mydsl.myDsl.relational_expression;
import org.xtext.example.mydsl.myDsl.relational_expression_complement;
import org.xtext.example.mydsl.myDsl.relational_expression_linha;
import org.xtext.example.mydsl.myDsl.selection_statement;
import org.xtext.example.mydsl.myDsl.shift_expression;
import org.xtext.example.mydsl.myDsl.shift_expression_complement;
import org.xtext.example.mydsl.myDsl.shift_expression_linha;
import org.xtext.example.mydsl.myDsl.specifier_qualifier_list;
import org.xtext.example.mydsl.myDsl.statement;
import org.xtext.example.mydsl.myDsl.static_assert_declaration;
import org.xtext.example.mydsl.myDsl.string_ufcg;
import org.xtext.example.mydsl.myDsl.struct_declaration;
import org.xtext.example.mydsl.myDsl.struct_declaration_list;
import org.xtext.example.mydsl.myDsl.struct_declarator;
import org.xtext.example.mydsl.myDsl.struct_declarator_list;
import org.xtext.example.mydsl.myDsl.struct_or_union_specifier;
import org.xtext.example.mydsl.myDsl.translation_unit;
import org.xtext.example.mydsl.myDsl.type_name;
import org.xtext.example.mydsl.myDsl.type_qualifier;
import org.xtext.example.mydsl.myDsl.type_qualifier_list;
import org.xtext.example.mydsl.myDsl.type_specifier;
import org.xtext.example.mydsl.myDsl.unary_expression;
import org.xtext.example.mydsl.services.MyDslGrammarAccess;

@SuppressWarnings("all")
public class MyDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MyDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MyDslPackage.ARGUMENT_EXPRESSION_LIST_LINHA_ACTION:
				sequence_argument_expression_list_linha(context, (ArgumentExpressionListLinhaAction) semanticObject); 
				return; 
			case MyDslPackage.DECLARATION_LIST_LINHA_ACTION:
				sequence_declaration_list_linha(context, (DeclarationListLinhaAction) semanticObject); 
				return; 
			case MyDslPackage.DESIGNATOR_LIST_LINHA_ACTION:
				sequence_designator_list_linha(context, (DesignatorListLinhaAction) semanticObject); 
				return; 
			case MyDslPackage.DIRECT_ABSTRACT_DECLARRATOR_LINHA_ACTION:
				sequence_direct_abstract_declarator_linha(context, (DirectAbstractDeclarratorLinhaAction) semanticObject); 
				return; 
			case MyDslPackage.ENUMERATOR_LIST_LINHA_ACTION:
				sequence_enumerator_list_linha(context, (EnumeratorListLinhaAction) semanticObject); 
				return; 
			case MyDslPackage.GENERIC_ASSOC_LIST_LINHA_ACTION:
				sequence_generic_assoc_list_linha(context, (GenericAssocListLinhaAction) semanticObject); 
				return; 
			case MyDslPackage.IDENTIFIER_LIST_LINHA_ACTION:
				sequence_identifier_list_linha(context, (IdentifierListLinhaAction) semanticObject); 
				return; 
			case MyDslPackage.INIT_DECCLARATOR_LIST_LINHA_ACTION:
				sequence_init_declarator_list_linha(context, (InitDecclaratorListLinhaAction) semanticObject); 
				return; 
			case MyDslPackage.INITIALIZER_LIST_LINHA_ACTION:
				sequence_initializer_list_linha(context, (InitializerListLinhaAction) semanticObject); 
				return; 
			case MyDslPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case MyDslPackage.PLUS_PLUS:
				sequence_unary_expression(context, (PlusPlus) semanticObject); 
				return; 
			case MyDslPackage.POST_FIX_EMPRY_PARAMS:
				sequence_postfix_expression_complement(context, (PostFixEmpryParams) semanticObject); 
				return; 
			case MyDslPackage.POSTFIX_EXPRESSION_LINHA_ACTION:
				sequence_postfix_expression_linha(context, (PostfixExpressionLinhaAction) semanticObject); 
				return; 
			case MyDslPackage.STRUCT_DECLARATION_LIST_LINHA_ACTION:
				sequence_struct_declaration_list_linha(context, (StructDeclarationListLinhaAction) semanticObject); 
				return; 
			case MyDslPackage.STRUCT_DECLARATOR_LIST_LINHA_ACTION:
				sequence_struct_declarator_list_linha(context, (StructDeclaratorListLinhaAction) semanticObject); 
				return; 
			case MyDslPackage.STRUCT_OR_UNION_SPECIFIER_COMPLEMENT_ACTION:
				sequence_struct_or_union_specifier_complement(context, (StructOrUnionSpecifierComplementAction) semanticObject); 
				return; 
			case MyDslPackage.TRANLATION_UNIT_LINHA_ACTION:
				sequence_translation_unit_linha(context, (TranlationUnitLinhaAction) semanticObject); 
				return; 
			case MyDslPackage.TYPE_QUALIFIER_LIST_LINHA_ATION:
				sequence_type_qualifier_list_linha(context, (TypeQualifierListLinhaAtion) semanticObject); 
				return; 
			case MyDslPackage.ABSTRACT_DECLARATOR:
				sequence_abstract_declarator(context, (abstract_declarator) semanticObject); 
				return; 
			case MyDslPackage.ADDITIVE_EXPRESSION:
				sequence_additive_expression(context, (additive_expression) semanticObject); 
				return; 
			case MyDslPackage.ADDITIVE_EXPRESSION_COMPLEMENT:
				sequence_additive_expression_complement(context, (additive_expression_complement) semanticObject); 
				return; 
			case MyDslPackage.ADDITIVE_EXPRESSION_LINHA:
				sequence_additive_expression_linha(context, (additive_expression_linha) semanticObject); 
				return; 
			case MyDslPackage.ALIGNMENT_SPECIFIER:
				sequence_alignment_specifier(context, (alignment_specifier) semanticObject); 
				return; 
			case MyDslPackage.AND_EXPRESSION:
				sequence_and_expression(context, (and_expression) semanticObject); 
				return; 
			case MyDslPackage.AND_EXPRESSION_LINHA:
				sequence_and_expression_linha(context, (and_expression_linha) semanticObject); 
				return; 
			case MyDslPackage.ARGUMENT_EXPRESSION_LIST:
				sequence_argument_expression_list(context, (argument_expression_list) semanticObject); 
				return; 
			case MyDslPackage.ASSIGNMENT_EXPRESSION:
				sequence_assignment_expression(context, (assignment_expression) semanticObject); 
				return; 
			case MyDslPackage.ATOMIC_TYPE_SPECIFIER:
				sequence_atomic_type_specifier(context, (atomic_type_specifier) semanticObject); 
				return; 
			case MyDslPackage.BLOCK_ITEM:
				sequence_block_item(context, (block_item) semanticObject); 
				return; 
			case MyDslPackage.BLOCK_ITEM_LIST:
				sequence_block_item_list(context, (block_item_list) semanticObject); 
				return; 
			case MyDslPackage.BLOCK_ITEM_LIST_LINHA:
				sequence_block_item_list_linha(context, (block_item_list_linha) semanticObject); 
				return; 
			case MyDslPackage.CAST_EXPRESSION:
				sequence_cast_expression(context, (cast_expression) semanticObject); 
				return; 
			case MyDslPackage.COMPOUND_STATEMENT:
				sequence_compound_statement(context, (compound_statement) semanticObject); 
				return; 
			case MyDslPackage.CONDITIONAL_EXPRESSION:
				sequence_conditional_expression(context, (conditional_expression) semanticObject); 
				return; 
			case MyDslPackage.CONDITIONAL_EXPRESSION_LINHA:
				sequence_conditional_expression_linha(context, (conditional_expression_linha) semanticObject); 
				return; 
			case MyDslPackage.CONSTANT:
				sequence_constant(context, (constant) semanticObject); 
				return; 
			case MyDslPackage.CONSTANT_EXPRESSION:
				sequence_constant_expression(context, (constant_expression) semanticObject); 
				return; 
			case MyDslPackage.DECLARATION:
				sequence_declaration(context, (declaration) semanticObject); 
				return; 
			case MyDslPackage.DECLARATION_LIST:
				sequence_declaration_list(context, (declaration_list) semanticObject); 
				return; 
			case MyDslPackage.DECLARATION_SPECIFIERS:
				sequence_declaration_specifiers(context, (declaration_specifiers) semanticObject); 
				return; 
			case MyDslPackage.DECLARATOR:
				sequence_declarator(context, (declarator) semanticObject); 
				return; 
			case MyDslPackage.DESIGNATION:
				sequence_designation(context, (designation) semanticObject); 
				return; 
			case MyDslPackage.DESIGNATOR:
				sequence_designator(context, (designator) semanticObject); 
				return; 
			case MyDslPackage.DESIGNATOR_LIST:
				sequence_designator_list(context, (designator_list) semanticObject); 
				return; 
			case MyDslPackage.DIRECT_ABSTRACT_DECLARATOR:
				sequence_direct_abstract_declarator(context, (direct_abstract_declarator) semanticObject); 
				return; 
			case MyDslPackage.DIRECT_ABSTRACT_DECLARATOR_COMPLEMENT:
				sequence_direct_abstract_declarator_complement(context, (direct_abstract_declarator_complement) semanticObject); 
				return; 
			case MyDslPackage.DIRECT_DECLARATOR:
				sequence_direct_declarator(context, (direct_declarator) semanticObject); 
				return; 
			case MyDslPackage.DIRECT_DECLARATOR_COMPLEMENTO:
				sequence_direct_declarator_complemento(context, (direct_declarator_complemento) semanticObject); 
				return; 
			case MyDslPackage.DIRECT_DECLARATOR_LINHA:
				sequence_direct_declarator_linha(context, (direct_declarator_linha) semanticObject); 
				return; 
			case MyDslPackage.ENUM_SPECIFIER:
				sequence_enum_specifier(context, (enum_specifier) semanticObject); 
				return; 
			case MyDslPackage.ENUMERATION_CONSTANT:
				sequence_enumeration_constant(context, (enumeration_constant) semanticObject); 
				return; 
			case MyDslPackage.ENUMERATOR:
				sequence_enumerator(context, (enumerator) semanticObject); 
				return; 
			case MyDslPackage.ENUMERATOR_LIST:
				sequence_enumerator_list(context, (enumerator_list) semanticObject); 
				return; 
			case MyDslPackage.EQUALITY_EXPRESSION:
				sequence_equality_expression(context, (equality_expression) semanticObject); 
				return; 
			case MyDslPackage.EQUALITY_EXPRESSION_COMPLEMENT:
				sequence_equality_expression_complement(context, (equality_expression_complement) semanticObject); 
				return; 
			case MyDslPackage.EQUALITY_EXPRESSION_LINHA:
				sequence_equality_expression_linha(context, (equality_expression_linha) semanticObject); 
				return; 
			case MyDslPackage.EXCLUSIVE_OR_EXPRESSION:
				sequence_exclusive_or_expression(context, (exclusive_or_expression) semanticObject); 
				return; 
			case MyDslPackage.EXCLUSIVE_OR_EXPRESSION_LINHA:
				sequence_exclusive_or_expression_linha(context, (exclusive_or_expression_linha) semanticObject); 
				return; 
			case MyDslPackage.EXPRESSION:
				sequence_expression(context, (expression) semanticObject); 
				return; 
			case MyDslPackage.EXPRESSION_LINHA:
				sequence_expression_linha(context, (expression_linha) semanticObject); 
				return; 
			case MyDslPackage.EXPRESSION_STATEMENT:
				sequence_expression_statement(context, (expression_statement) semanticObject); 
				return; 
			case MyDslPackage.EXTERNAL_DECLARATION:
				sequence_external_declaration(context, (external_declaration) semanticObject); 
				return; 
			case MyDslPackage.FUNCTION_DEFINITION:
				sequence_function_definition(context, (function_definition) semanticObject); 
				return; 
			case MyDslPackage.GENERIC_ASSOC_LIST:
				sequence_generic_assoc_list(context, (generic_assoc_list) semanticObject); 
				return; 
			case MyDslPackage.GENERIC_ASSOCIATION:
				sequence_generic_association(context, (generic_association) semanticObject); 
				return; 
			case MyDslPackage.GENERIC_SELECTION:
				sequence_generic_selection(context, (generic_selection) semanticObject); 
				return; 
			case MyDslPackage.IDENTIFIER_LIST:
				sequence_identifier_list(context, (identifier_list) semanticObject); 
				return; 
			case MyDslPackage.INCLUSIVE_OR_EXPRESSION:
				sequence_inclusive_or_expression(context, (inclusive_or_expression) semanticObject); 
				return; 
			case MyDslPackage.INCLUSIVE_OR_EXPRESSION_LINHA:
				sequence_inclusive_or_expression_linha(context, (inclusive_or_expression_linha) semanticObject); 
				return; 
			case MyDslPackage.INIT_DECLARATOR:
				sequence_init_declarator(context, (init_declarator) semanticObject); 
				return; 
			case MyDslPackage.INIT_DECLARATOR_LIST:
				sequence_init_declarator_list(context, (init_declarator_list) semanticObject); 
				return; 
			case MyDslPackage.INITIALIZER:
				sequence_initializer(context, (initializer) semanticObject); 
				return; 
			case MyDslPackage.INITIALIZER_LIST:
				sequence_initializer_list(context, (initializer_list) semanticObject); 
				return; 
			case MyDslPackage.INITIALIZER_LIST_COMPLEMENT:
				sequence_initializer_list_complement(context, (initializer_list_complement) semanticObject); 
				return; 
			case MyDslPackage.ITERATION_STATEMENT:
				sequence_iteration_statement(context, (iteration_statement) semanticObject); 
				return; 
			case MyDslPackage.JUMP_STATEMENT:
				sequence_jump_statement(context, (jump_statement) semanticObject); 
				return; 
			case MyDslPackage.LABELED_STATEMENT:
				sequence_labeled_statement(context, (labeled_statement) semanticObject); 
				return; 
			case MyDslPackage.LOGICAL_AND_EXPRESSION:
				sequence_logical_and_expression(context, (logical_and_expression) semanticObject); 
				return; 
			case MyDslPackage.LOGICAL_AND_EXPRESSION_LINHA:
				sequence_logical_and_expression_linha(context, (logical_and_expression_linha) semanticObject); 
				return; 
			case MyDslPackage.LOGICAL_OR_EXPRESSION:
				sequence_logical_or_expression(context, (logical_or_expression) semanticObject); 
				return; 
			case MyDslPackage.LOGICAL_OR_EXPRESSION_LINHA:
				sequence_logical_or_expression_linha(context, (logical_or_expression_linha) semanticObject); 
				return; 
			case MyDslPackage.MULTIPLICATIVE_EXPRESSION:
				sequence_multiplicative_expression(context, (multiplicative_expression) semanticObject); 
				return; 
			case MyDslPackage.MULTIPLICATIVE_EXPRESSION_COMPLEMENT:
				sequence_multiplicative_expression_complement(context, (multiplicative_expression_complement) semanticObject); 
				return; 
			case MyDslPackage.MULTIPLICATIVE_EXPRESSION_LINHA:
				sequence_multiplicative_expression_linha(context, (multiplicative_expression_linha) semanticObject); 
				return; 
			case MyDslPackage.PARAMETER_DECLARATION:
				sequence_parameter_declaration(context, (parameter_declaration) semanticObject); 
				return; 
			case MyDslPackage.PARAMETER_LIST_LINHA:
				sequence_parameter_list_linha(context, (parameter_list_linha) semanticObject); 
				return; 
			case MyDslPackage.PARAMETER_LISTA:
				sequence_parameter_lista(context, (parameter_lista) semanticObject); 
				return; 
			case MyDslPackage.PARAMETER_TYPE_LIST:
				sequence_parameter_type_list(context, (parameter_type_list) semanticObject); 
				return; 
			case MyDslPackage.POINTER:
				sequence_pointer(context, (pointer) semanticObject); 
				return; 
			case MyDslPackage.POSTFIX_EXPRESSION:
				sequence_postfix_expression(context, (postfix_expression) semanticObject); 
				return; 
			case MyDslPackage.POSTFIX_EXPRESSION_COMPLEMENT:
				sequence_postfix_expression_complement(context, (postfix_expression_complement) semanticObject); 
				return; 
			case MyDslPackage.PRIMARY_EXPRESSION:
				sequence_primary_expression(context, (primary_expression) semanticObject); 
				return; 
			case MyDslPackage.RELATIONAL_EXPRESSION:
				sequence_relational_expression(context, (relational_expression) semanticObject); 
				return; 
			case MyDslPackage.RELATIONAL_EXPRESSION_COMPLEMENT:
				sequence_relational_expression_complement(context, (relational_expression_complement) semanticObject); 
				return; 
			case MyDslPackage.RELATIONAL_EXPRESSION_LINHA:
				sequence_relational_expression_linha(context, (relational_expression_linha) semanticObject); 
				return; 
			case MyDslPackage.SELECTION_STATEMENT:
				sequence_selection_statement(context, (selection_statement) semanticObject); 
				return; 
			case MyDslPackage.SHIFT_EXPRESSION:
				sequence_shift_expression(context, (shift_expression) semanticObject); 
				return; 
			case MyDslPackage.SHIFT_EXPRESSION_COMPLEMENT:
				sequence_shift_expression_complement(context, (shift_expression_complement) semanticObject); 
				return; 
			case MyDslPackage.SHIFT_EXPRESSION_LINHA:
				sequence_shift_expression_linha(context, (shift_expression_linha) semanticObject); 
				return; 
			case MyDslPackage.SPECIFIER_QUALIFIER_LIST:
				sequence_specifier_qualifier_list(context, (specifier_qualifier_list) semanticObject); 
				return; 
			case MyDslPackage.STATEMENT:
				sequence_statement(context, (statement) semanticObject); 
				return; 
			case MyDslPackage.STATIC_ASSERT_DECLARATION:
				sequence_static_assert_declaration(context, (static_assert_declaration) semanticObject); 
				return; 
			case MyDslPackage.STRING_UFCG:
				sequence_string_ufcg(context, (string_ufcg) semanticObject); 
				return; 
			case MyDslPackage.STRUCT_DECLARATION:
				sequence_struct_declaration(context, (struct_declaration) semanticObject); 
				return; 
			case MyDslPackage.STRUCT_DECLARATION_LIST:
				sequence_struct_declaration_list(context, (struct_declaration_list) semanticObject); 
				return; 
			case MyDslPackage.STRUCT_DECLARATOR:
				sequence_struct_declarator(context, (struct_declarator) semanticObject); 
				return; 
			case MyDslPackage.STRUCT_DECLARATOR_LIST:
				sequence_struct_declarator_list(context, (struct_declarator_list) semanticObject); 
				return; 
			case MyDslPackage.STRUCT_OR_UNION_SPECIFIER:
				sequence_struct_or_union_specifier(context, (struct_or_union_specifier) semanticObject); 
				return; 
			case MyDslPackage.TRANSLATION_UNIT:
				sequence_translation_unit(context, (translation_unit) semanticObject); 
				return; 
			case MyDslPackage.TYPE_NAME:
				if (rule == grammarAccess.getPostfix_expressionRule()) {
					sequence_postfix_expression_type_name(context, (type_name) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getType_nameRule()) {
					sequence_type_name(context, (type_name) semanticObject); 
					return; 
				}
				else break;
			case MyDslPackage.TYPE_QUALIFIER:
				sequence_type_qualifier(context, (type_qualifier) semanticObject); 
				return; 
			case MyDslPackage.TYPE_QUALIFIER_LIST:
				if (rule == grammarAccess.getDirect_abstract_declarator_complementRule()) {
					sequence_direct_abstract_declarator_complement_type_qualifier_list(context, (type_qualifier_list) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getType_qualifier_listRule()) {
					sequence_type_qualifier_list(context, (type_qualifier_list) semanticObject); 
					return; 
				}
				else break;
			case MyDslPackage.TYPE_SPECIFIER:
				sequence_type_specifier(context, (type_specifier) semanticObject); 
				return; 
			case MyDslPackage.UNARY_EXPRESSION:
				sequence_unary_expression(context, (unary_expression) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     greetings+=translation_unit
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     abstract_declarator returns abstract_declarator
	 *
	 * Constraint:
	 *     ((pointer=pointer direct_abstract_declarator=direct_abstract_declarator) | pointer=pointer | direct_abstract_declarator=direct_abstract_declarator)
	 */
	protected void sequence_abstract_declarator(ISerializationContext context, abstract_declarator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     additive_expression returns additive_expression
	 *
	 * Constraint:
	 *     (multiplicative_expression=multiplicative_expression additive_expression_linha=additive_expression_linha)
	 */
	protected void sequence_additive_expression(ISerializationContext context, additive_expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ADDITIVE_EXPRESSION__MULTIPLICATIVE_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ADDITIVE_EXPRESSION__MULTIPLICATIVE_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ADDITIVE_EXPRESSION__ADDITIVE_EXPRESSION_LINHA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ADDITIVE_EXPRESSION__ADDITIVE_EXPRESSION_LINHA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditive_expressionAccess().getMultiplicative_expressionMultiplicative_expressionParserRuleCall_0_0(), semanticObject.getMultiplicative_expression());
		feeder.accept(grammarAccess.getAdditive_expressionAccess().getAdditive_expression_linhaAdditive_expression_linhaParserRuleCall_1_0(), semanticObject.getAdditive_expression_linha());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     additive_expression_complement returns additive_expression_complement
	 *
	 * Constraint:
	 *     ((mais='+' multiplicative_expression=multiplicative_expression) | (menos='-' multiplicative_expression=multiplicative_expression))
	 */
	protected void sequence_additive_expression_complement(ISerializationContext context, additive_expression_complement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     additive_expression_linha returns additive_expression_linha
	 *
	 * Constraint:
	 *     (additive_expression_complement=additive_expression_complement additive_expression_linha=additive_expression_linha)
	 */
	protected void sequence_additive_expression_linha(ISerializationContext context, additive_expression_linha semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ADDITIVE_EXPRESSION_LINHA__ADDITIVE_EXPRESSION_COMPLEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ADDITIVE_EXPRESSION_LINHA__ADDITIVE_EXPRESSION_COMPLEMENT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ADDITIVE_EXPRESSION_LINHA__ADDITIVE_EXPRESSION_LINHA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ADDITIVE_EXPRESSION_LINHA__ADDITIVE_EXPRESSION_LINHA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditive_expression_linhaAccess().getAdditive_expression_complementAdditive_expression_complementParserRuleCall_0_0(), semanticObject.getAdditive_expression_complement());
		feeder.accept(grammarAccess.getAdditive_expression_linhaAccess().getAdditive_expression_linhaAdditive_expression_linhaParserRuleCall_1_0(), semanticObject.getAdditive_expression_linha());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     alignment_specifier returns alignment_specifier
	 *
	 * Constraint:
	 *     (type_name=type_name | constant_expression=constant_expression)
	 */
	protected void sequence_alignment_specifier(ISerializationContext context, alignment_specifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     and_expression returns and_expression
	 *
	 * Constraint:
	 *     (equality_expression=equality_expression and_expression_linha=and_expression_linha)
	 */
	protected void sequence_and_expression(ISerializationContext context, and_expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.AND_EXPRESSION__EQUALITY_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.AND_EXPRESSION__EQUALITY_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.AND_EXPRESSION__AND_EXPRESSION_LINHA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.AND_EXPRESSION__AND_EXPRESSION_LINHA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAnd_expressionAccess().getEquality_expressionEquality_expressionParserRuleCall_0_0(), semanticObject.getEquality_expression());
		feeder.accept(grammarAccess.getAnd_expressionAccess().getAnd_expression_linhaAnd_expression_linhaParserRuleCall_1_0(), semanticObject.getAnd_expression_linha());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     and_expression_linha returns and_expression_linha
	 *
	 * Constraint:
	 *     (equality_expression=equality_expression and_expression_linha=and_expression_linha)
	 */
	protected void sequence_and_expression_linha(ISerializationContext context, and_expression_linha semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.AND_EXPRESSION_LINHA__EQUALITY_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.AND_EXPRESSION_LINHA__EQUALITY_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.AND_EXPRESSION_LINHA__AND_EXPRESSION_LINHA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.AND_EXPRESSION_LINHA__AND_EXPRESSION_LINHA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAnd_expression_linhaAccess().getEquality_expressionEquality_expressionParserRuleCall_1_0(), semanticObject.getEquality_expression());
		feeder.accept(grammarAccess.getAnd_expression_linhaAccess().getAnd_expression_linhaAnd_expression_linhaParserRuleCall_2_0(), semanticObject.getAnd_expression_linha());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     argument_expression_list returns argument_expression_list
	 *
	 * Constraint:
	 *     (assignment_expressions+=assignment_expression assignment_expressions+=assignment_expression*)
	 */
	protected void sequence_argument_expression_list(ISerializationContext context, argument_expression_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     argument_expression_list_linha returns ArgumentExpressionListLinhaAction
	 *
	 * Constraint:
	 *     (assignment_expression=assignment_expression argument_expression_list_linha=argument_expression_list_linha)?
	 */
	protected void sequence_argument_expression_list_linha(ISerializationContext context, ArgumentExpressionListLinhaAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     assignment_expression returns assignment_expression
	 *
	 * Constraint:
	 *     (
	 *         conditional_expression=conditional_expression | 
	 *         (unary_expression=unary_expression assignment_operator=assignment_operator assignment_expression=assignment_expression)
	 *     )
	 */
	protected void sequence_assignment_expression(ISerializationContext context, assignment_expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     atomic_type_specifier returns atomic_type_specifier
	 *
	 * Constraint:
	 *     type_name=type_name
	 */
	protected void sequence_atomic_type_specifier(ISerializationContext context, atomic_type_specifier semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ATOMIC_TYPE_SPECIFIER__TYPE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ATOMIC_TYPE_SPECIFIER__TYPE_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomic_type_specifierAccess().getType_nameType_nameParserRuleCall_2_0(), semanticObject.getType_name());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     block_item returns block_item
	 *
	 * Constraint:
	 *     (declaration=declaration | statement=statement)
	 */
	protected void sequence_block_item(ISerializationContext context, block_item semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     block_item_list returns block_item_list
	 *
	 * Constraint:
	 *     (block_item=block_item block_item_list_linha+=block_item_list_linha?)
	 */
	protected void sequence_block_item_list(ISerializationContext context, block_item_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     block_item_list_linha returns block_item_list_linha
	 *
	 * Constraint:
	 *     (block_item=block_item block_item_list_linha+=block_item_list_linha?)
	 */
	protected void sequence_block_item_list_linha(ISerializationContext context, block_item_list_linha semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     cast_expression returns cast_expression
	 *
	 * Constraint:
	 *     (unary_expression=unary_expression | (type_name=type_name cast_expression=cast_expression))
	 */
	protected void sequence_cast_expression(ISerializationContext context, cast_expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     compound_statement returns compound_statement
	 *
	 * Constraint:
	 *     block_item_list+=block_item_list
	 */
	protected void sequence_compound_statement(ISerializationContext context, compound_statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     conditional_expression returns conditional_expression
	 *
	 * Constraint:
	 *     (logical_or_expression=logical_or_expression conditional_expression_linha=conditional_expression_linha)
	 */
	protected void sequence_conditional_expression(ISerializationContext context, conditional_expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.CONDITIONAL_EXPRESSION__LOGICAL_OR_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.CONDITIONAL_EXPRESSION__LOGICAL_OR_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.CONDITIONAL_EXPRESSION__CONDITIONAL_EXPRESSION_LINHA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.CONDITIONAL_EXPRESSION__CONDITIONAL_EXPRESSION_LINHA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditional_expressionAccess().getLogical_or_expressionLogical_or_expressionParserRuleCall_0_0(), semanticObject.getLogical_or_expression());
		feeder.accept(grammarAccess.getConditional_expressionAccess().getConditional_expression_linhaConditional_expression_linhaParserRuleCall_1_0(), semanticObject.getConditional_expression_linha());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     conditional_expression_linha returns conditional_expression_linha
	 *
	 * Constraint:
	 *     (expression=expression conditional_expression=conditional_expression conditional_expression_linha=conditional_expression_linha)
	 */
	protected void sequence_conditional_expression_linha(ISerializationContext context, conditional_expression_linha semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.CONDITIONAL_EXPRESSION_LINHA__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.CONDITIONAL_EXPRESSION_LINHA__EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.CONDITIONAL_EXPRESSION_LINHA__CONDITIONAL_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.CONDITIONAL_EXPRESSION_LINHA__CONDITIONAL_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.CONDITIONAL_EXPRESSION_LINHA__CONDITIONAL_EXPRESSION_LINHA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.CONDITIONAL_EXPRESSION_LINHA__CONDITIONAL_EXPRESSION_LINHA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditional_expression_linhaAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getConditional_expression_linhaAccess().getConditional_expressionConditional_expressionParserRuleCall_3_0(), semanticObject.getConditional_expression());
		feeder.accept(grammarAccess.getConditional_expression_linhaAccess().getConditional_expression_linhaConditional_expression_linhaParserRuleCall_4_0(), semanticObject.getConditional_expression_linha());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     constant returns constant
	 *
	 * Constraint:
	 *     (i_constant=INT | f_constant=FLOAT | char=CHAR | enumz='enum')
	 */
	protected void sequence_constant(ISerializationContext context, constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     constant_expression returns constant_expression
	 *
	 * Constraint:
	 *     conditional_expression=conditional_expression
	 */
	protected void sequence_constant_expression(ISerializationContext context, constant_expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.CONSTANT_EXPRESSION__CONDITIONAL_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.CONSTANT_EXPRESSION__CONDITIONAL_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstant_expressionAccess().getConditional_expressionConditional_expressionParserRuleCall_0(), semanticObject.getConditional_expression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     declaration returns declaration
	 *
	 * Constraint:
	 *     (
	 *         declaration_specifiers+=declaration_specifiers | 
	 *         (declaration_specifiers+=declaration_specifiers init_declarator_list+=init_declarator_list) | 
	 *         static_assert_declaration=static_assert_declaration
	 *     )
	 */
	protected void sequence_declaration(ISerializationContext context, declaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     declaration_list returns declaration_list
	 *
	 * Constraint:
	 *     (declaration=declaration declaration_list_linha=declaration_list_linha)
	 */
	protected void sequence_declaration_list(ISerializationContext context, declaration_list semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DECLARATION_LIST__DECLARATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DECLARATION_LIST__DECLARATION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DECLARATION_LIST__DECLARATION_LIST_LINHA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DECLARATION_LIST__DECLARATION_LIST_LINHA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDeclaration_listAccess().getDeclarationDeclarationParserRuleCall_0_0(), semanticObject.getDeclaration());
		feeder.accept(grammarAccess.getDeclaration_listAccess().getDeclaration_list_linhaDeclaration_list_linhaParserRuleCall_1_0(), semanticObject.getDeclaration_list_linha());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     declaration_list_linha returns DeclarationListLinhaAction
	 *
	 * Constraint:
	 *     (declaration=declaration declaration_list_linha=declaration_list_linha)?
	 */
	protected void sequence_declaration_list_linha(ISerializationContext context, DeclarationListLinhaAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     declaration_specifiers returns declaration_specifiers
	 *
	 * Constraint:
	 *     (
	 *         (storage_class_specifier=storage_class_specifier declaration_specifiers+=declaration_specifiers) | 
	 *         storage_class_specifier=storage_class_specifier | 
	 *         (type_specifier=type_specifier declaration_specifiers+=declaration_specifiers) | 
	 *         type_specifier=type_specifier | 
	 *         (type_qualifier=type_qualifier declaration_specifiers+=declaration_specifiers) | 
	 *         type_qualifier=type_qualifier | 
	 *         (function_specifier=function_specifier declaration_specifiers+=declaration_specifiers) | 
	 *         function_specifier=function_specifier | 
	 *         (alignment_specifier=alignment_specifier declaration_specifiers+=declaration_specifiers) | 
	 *         alignment_specifier=alignment_specifier
	 *     )
	 */
	protected void sequence_declaration_specifiers(ISerializationContext context, declaration_specifiers semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     declarator returns declarator
	 *
	 * Constraint:
	 *     ((pointer=pointer direct_declarator=direct_declarator) | direct_declarator=direct_declarator)
	 */
	protected void sequence_declarator(ISerializationContext context, declarator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     designation returns designation
	 *
	 * Constraint:
	 *     designator_list=designator_list
	 */
	protected void sequence_designation(ISerializationContext context, designation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DESIGNATION__DESIGNATOR_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DESIGNATION__DESIGNATOR_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDesignationAccess().getDesignator_listDesignator_listParserRuleCall_0_0(), semanticObject.getDesignator_list());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     designator returns designator
	 *
	 * Constraint:
	 *     (constant_expression=conditional_expression | identifier=IDz)
	 */
	protected void sequence_designator(ISerializationContext context, designator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     designator_list returns designator_list
	 *
	 * Constraint:
	 *     (designator=designator designator_list_linha=designator_list_linha)
	 */
	protected void sequence_designator_list(ISerializationContext context, designator_list semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DESIGNATOR_LIST__DESIGNATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DESIGNATOR_LIST__DESIGNATOR));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DESIGNATOR_LIST__DESIGNATOR_LIST_LINHA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DESIGNATOR_LIST__DESIGNATOR_LIST_LINHA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDesignator_listAccess().getDesignatorDesignatorParserRuleCall_0_0(), semanticObject.getDesignator());
		feeder.accept(grammarAccess.getDesignator_listAccess().getDesignator_list_linhaDesignator_list_linhaParserRuleCall_1_0(), semanticObject.getDesignator_list_linha());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     designator_list_linha returns DesignatorListLinhaAction
	 *
	 * Constraint:
	 *     (designator=designator designator_list_linha=declaration_list_linha)?
	 */
	protected void sequence_designator_list_linha(ISerializationContext context, DesignatorListLinhaAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     direct_abstract_declarator_complement returns direct_abstract_declarator_complement
	 *
	 * Constraint:
	 *     (
	 *         assignment_expression=assignment_expression | 
	 *         (type_qualifier_list=type_qualifier_list assignment_expression=assignment_expression) | 
	 *         (type_qualifier_list=type_qualifier_list assignment_expression=assignment_expression) | 
	 *         type_qualifier_list=type_qualifier_list | 
	 *         assignment_expression=assignment_expression | 
	 *         parameter_type_list=parameter_type_list
	 *     )
	 */
	protected void sequence_direct_abstract_declarator_complement(ISerializationContext context, direct_abstract_declarator_complement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     direct_abstract_declarator_complement returns type_qualifier_list
	 *
	 * Constraint:
	 *     (type_qualifier=type_qualifier type_qualifier_list_linha=type_qualifier_list_linha assignment_expression=assignment_expression)
	 */
	protected void sequence_direct_abstract_declarator_complement_type_qualifier_list(ISerializationContext context, type_qualifier_list semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TYPE_QUALIFIER_LIST__TYPE_QUALIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TYPE_QUALIFIER_LIST__TYPE_QUALIFIER));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TYPE_QUALIFIER_LIST__TYPE_QUALIFIER_LIST_LINHA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TYPE_QUALIFIER_LIST__TYPE_QUALIFIER_LIST_LINHA));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DIRECT_ABSTRACT_DECLARATOR_COMPLEMENT__ASSIGNMENT_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DIRECT_ABSTRACT_DECLARATOR_COMPLEMENT__ASSIGNMENT_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getType_qualifier_listAccess().getType_qualifierType_qualifierParserRuleCall_0_0(), semanticObject.getType_qualifier());
		feeder.accept(grammarAccess.getType_qualifier_listAccess().getType_qualifier_list_linhaType_qualifier_list_linhaParserRuleCall_1_0(), semanticObject.getType_qualifier_list_linha());
		feeder.accept(grammarAccess.getDirect_abstract_declarator_complementAccess().getAssignment_expressionAssignment_expressionParserRuleCall_2_3_0(), semanticObject.getAssignment_expression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     direct_abstract_declarator returns direct_abstract_declarator
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             abstract_declarator=abstract_declarator | 
	 *             (type_qualifier_list=type_qualifier_list assignment_expression=assignment_expression) | 
	 *             assignment_expression=assignment_expression | 
	 *             (type_qualifier_list=type_qualifier_list assignment_expression=assignment_expression) | 
	 *             (type_qualifier_list=type_qualifier_list assignment_expression=assignment_expression) | 
	 *             type_qualifier_list=type_qualifier_list | 
	 *             assignment_expression=assignment_expression | 
	 *             parameter_type_list=parameter_type_list
	 *         )? 
	 *         direct_abstract_declarator_linha=direct_abstract_declarator_linha
	 *     )
	 */
	protected void sequence_direct_abstract_declarator(ISerializationContext context, direct_abstract_declarator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     direct_abstract_declarator_linha returns DirectAbstractDeclarratorLinhaAction
	 *
	 * Constraint:
	 *     (direct_abstract_declarator_complement=direct_abstract_declarator_complement direct_abstract_declarator_linha=direct_abstract_declarator_linha)?
	 */
	protected void sequence_direct_abstract_declarator_linha(ISerializationContext context, DirectAbstractDeclarratorLinhaAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     direct_declarator_complemento returns direct_declarator_complemento
	 *
	 * Constraint:
	 *     (
	 *         (type_qualifier_list=type_qualifier_list assignment_expression=assignment_expression) | 
	 *         assignment_expression=assignment_expression | 
	 *         type_qualifier_list=type_qualifier_list | 
	 *         (type_qualifier_list=type_qualifier_list assignment_expression=assignment_expression) | 
	 *         (type_qualifier_list=type_qualifier_list assignment_expression=assignment_expression) | 
	 *         type_qualifier_list=type_qualifier_list | 
	 *         assignment_expression=assignment_expression | 
	 *         parameter_type_list=parameter_type_list | 
	 *         identifier_list=identifier_list
	 *     )
	 */
	protected void sequence_direct_declarator_complemento(ISerializationContext context, direct_declarator_complemento semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     direct_declarator returns direct_declarator
	 *
	 * Constraint:
	 *     ((identifier=IDz direct_declarator_linha=direct_declarator_linha?) | (declarator=declarator direct_declarator_linha=direct_declarator_linha?))
	 */
	protected void sequence_direct_declarator(ISerializationContext context, direct_declarator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     direct_declarator_linha returns direct_declarator_linha
	 *
	 * Constraint:
	 *     (direct_declarator_complemento=direct_declarator_complemento direct_declarator_linha=direct_declarator_linha?)
	 */
	protected void sequence_direct_declarator_linha(ISerializationContext context, direct_declarator_linha semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     enum_specifier returns enum_specifier
	 *
	 * Constraint:
	 *     (
	 *         enumerator_list=enumerator_list | 
	 *         enumerator_list=enumerator_list | 
	 *         (identifier=IDz enumerator_list=enumerator_list) | 
	 *         (identifier=IDz enumerator_list=enumerator_list) | 
	 *         identifier=IDz
	 *     )
	 */
	protected void sequence_enum_specifier(ISerializationContext context, enum_specifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     enumeration_constant returns enumeration_constant
	 *
	 * Constraint:
	 *     identifier=IDz
	 */
	protected void sequence_enumeration_constant(ISerializationContext context, enumeration_constant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ENUMERATION_CONSTANT__IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ENUMERATION_CONSTANT__IDENTIFIER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumeration_constantAccess().getIdentifierIDzTerminalRuleCall_0(), semanticObject.getIdentifier());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     enumerator returns enumerator
	 *
	 * Constraint:
	 *     ((enumeration_constant=enumeration_constant conditional_expression=constant_expression) | enumeration_constant=enumeration_constant)
	 */
	protected void sequence_enumerator(ISerializationContext context, enumerator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     enumerator_list returns enumerator_list
	 *
	 * Constraint:
	 *     (enumarator=enumerator enumerator_list_linha=enumerator_list_linha)
	 */
	protected void sequence_enumerator_list(ISerializationContext context, enumerator_list semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ENUMERATOR_LIST__ENUMARATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ENUMERATOR_LIST__ENUMARATOR));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ENUMERATOR_LIST__ENUMERATOR_LIST_LINHA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ENUMERATOR_LIST__ENUMERATOR_LIST_LINHA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumerator_listAccess().getEnumaratorEnumeratorParserRuleCall_0_0(), semanticObject.getEnumarator());
		feeder.accept(grammarAccess.getEnumerator_listAccess().getEnumerator_list_linhaEnumerator_list_linhaParserRuleCall_1_0(), semanticObject.getEnumerator_list_linha());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     enumerator_list_linha returns EnumeratorListLinhaAction
	 *
	 * Constraint:
	 *     (enumerator=enumerator enumerator_list_linha=enumerator_list_linha)?
	 */
	protected void sequence_enumerator_list_linha(ISerializationContext context, EnumeratorListLinhaAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     equality_expression_complement returns equality_expression_complement
	 *
	 * Constraint:
	 *     (
	 *         (igual='==' relational_expression=relational_expression) | 
	 *         (menor='<' relational_expression=relational_expression) | 
	 *         (maior='>' relational_expression=relational_expression) | 
	 *         (menor_igual='<=' relational_expression=relational_expression) | 
	 *         (maior_igual='>=' relational_expression=relational_expression) | 
	 *         (n_igual='!=' relational_expression=relational_expression)
	 *     )
	 */
	protected void sequence_equality_expression_complement(ISerializationContext context, equality_expression_complement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     equality_expression returns equality_expression
	 *
	 * Constraint:
	 *     (relational_expression=relational_expression equality_expression_linha=equality_expression_linha)
	 */
	protected void sequence_equality_expression(ISerializationContext context, equality_expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EQUALITY_EXPRESSION__RELATIONAL_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EQUALITY_EXPRESSION__RELATIONAL_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EQUALITY_EXPRESSION__EQUALITY_EXPRESSION_LINHA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EQUALITY_EXPRESSION__EQUALITY_EXPRESSION_LINHA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEquality_expressionAccess().getRelational_expressionRelational_expressionParserRuleCall_0_0(), semanticObject.getRelational_expression());
		feeder.accept(grammarAccess.getEquality_expressionAccess().getEquality_expression_linhaEquality_expression_linhaParserRuleCall_1_0(), semanticObject.getEquality_expression_linha());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     equality_expression_linha returns equality_expression_linha
	 *
	 * Constraint:
	 *     (equality_expression_complement=equality_expression_complement equality_expression_linha=equality_expression_linha)
	 */
	protected void sequence_equality_expression_linha(ISerializationContext context, equality_expression_linha semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EQUALITY_EXPRESSION_LINHA__EQUALITY_EXPRESSION_COMPLEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EQUALITY_EXPRESSION_LINHA__EQUALITY_EXPRESSION_COMPLEMENT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EQUALITY_EXPRESSION_LINHA__EQUALITY_EXPRESSION_LINHA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EQUALITY_EXPRESSION_LINHA__EQUALITY_EXPRESSION_LINHA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEquality_expression_linhaAccess().getEquality_expression_complementEquality_expression_complementParserRuleCall_0_0(), semanticObject.getEquality_expression_complement());
		feeder.accept(grammarAccess.getEquality_expression_linhaAccess().getEquality_expression_linhaEquality_expression_linhaParserRuleCall_1_0(), semanticObject.getEquality_expression_linha());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     exclusive_or_expression returns exclusive_or_expression
	 *
	 * Constraint:
	 *     (and_expression=and_expression exclusive_or_expression_linha=exclusive_or_expression_linha)
	 */
	protected void sequence_exclusive_or_expression(ISerializationContext context, exclusive_or_expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EXCLUSIVE_OR_EXPRESSION__AND_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EXCLUSIVE_OR_EXPRESSION__AND_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EXCLUSIVE_OR_EXPRESSION__EXCLUSIVE_OR_EXPRESSION_LINHA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EXCLUSIVE_OR_EXPRESSION__EXCLUSIVE_OR_EXPRESSION_LINHA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExclusive_or_expressionAccess().getAnd_expressionAnd_expressionParserRuleCall_0_0(), semanticObject.getAnd_expression());
		feeder.accept(grammarAccess.getExclusive_or_expressionAccess().getExclusive_or_expression_linhaExclusive_or_expression_linhaParserRuleCall_1_0(), semanticObject.getExclusive_or_expression_linha());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     exclusive_or_expression_linha returns exclusive_or_expression_linha
	 *
	 * Constraint:
	 *     (and_expression=and_expression exclusive_or_expression_linha=exclusive_or_expression_linha)
	 */
	protected void sequence_exclusive_or_expression_linha(ISerializationContext context, exclusive_or_expression_linha semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EXCLUSIVE_OR_EXPRESSION_LINHA__AND_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EXCLUSIVE_OR_EXPRESSION_LINHA__AND_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EXCLUSIVE_OR_EXPRESSION_LINHA__EXCLUSIVE_OR_EXPRESSION_LINHA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EXCLUSIVE_OR_EXPRESSION_LINHA__EXCLUSIVE_OR_EXPRESSION_LINHA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExclusive_or_expression_linhaAccess().getAnd_expressionAnd_expressionParserRuleCall_1_0(), semanticObject.getAnd_expression());
		feeder.accept(grammarAccess.getExclusive_or_expression_linhaAccess().getExclusive_or_expression_linhaExclusive_or_expression_linhaParserRuleCall_2_0(), semanticObject.getExclusive_or_expression_linha());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     expression returns expression
	 *
	 * Constraint:
	 *     (assignment_expression=assignment_expression expression_linha=expression_linha)
	 */
	protected void sequence_expression(ISerializationContext context, expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EXPRESSION__ASSIGNMENT_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EXPRESSION__ASSIGNMENT_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EXPRESSION__EXPRESSION_LINHA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EXPRESSION__EXPRESSION_LINHA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionAccess().getAssignment_expressionAssignment_expressionParserRuleCall_0_0(), semanticObject.getAssignment_expression());
		feeder.accept(grammarAccess.getExpressionAccess().getExpression_linhaExpression_linhaParserRuleCall_1_0(), semanticObject.getExpression_linha());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     expression_linha returns expression_linha
	 *
	 * Constraint:
	 *     (assignment_expression=assignment_expression expression_linha=expression_linha)
	 */
	protected void sequence_expression_linha(ISerializationContext context, expression_linha semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EXPRESSION_LINHA__ASSIGNMENT_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EXPRESSION_LINHA__ASSIGNMENT_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EXPRESSION_LINHA__EXPRESSION_LINHA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EXPRESSION_LINHA__EXPRESSION_LINHA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpression_linhaAccess().getAssignment_expressionAssignment_expressionParserRuleCall_1_0(), semanticObject.getAssignment_expression());
		feeder.accept(grammarAccess.getExpression_linhaAccess().getExpression_linhaExpression_linhaParserRuleCall_2_0(), semanticObject.getExpression_linha());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     expression_statement returns expression_statement
	 *
	 * Constraint:
	 *     expression=expression
	 */
	protected void sequence_expression_statement(ISerializationContext context, expression_statement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EXPRESSION_STATEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EXPRESSION_STATEMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpression_statementAccess().getExpressionExpressionParserRuleCall_1_0_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     external_declaration returns external_declaration
	 *
	 * Constraint:
	 *     (function_definitio=function_definition | declaration=declaration)
	 */
	protected void sequence_external_declaration(ISerializationContext context, external_declaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     function_definition returns function_definition
	 *
	 * Constraint:
	 *     (
	 *         (declaration_specifiers+=declaration_specifiers declarator=declarator declaration_list+=declaration_list compound_statement=compound_statement) | 
	 *         (declaration_specifiers+=declaration_specifiers declarator=declarator compound_statement=compound_statement)
	 *     )
	 */
	protected void sequence_function_definition(ISerializationContext context, function_definition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     generic_assoc_list returns generic_assoc_list
	 *
	 * Constraint:
	 *     (generic_association=generic_association generic_assoc_list_linha=generic_assoc_list_linha)
	 */
	protected void sequence_generic_assoc_list(ISerializationContext context, generic_assoc_list semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.GENERIC_ASSOC_LIST__GENERIC_ASSOCIATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.GENERIC_ASSOC_LIST__GENERIC_ASSOCIATION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.GENERIC_ASSOC_LIST__GENERIC_ASSOC_LIST_LINHA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.GENERIC_ASSOC_LIST__GENERIC_ASSOC_LIST_LINHA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGeneric_assoc_listAccess().getGeneric_associationGeneric_associationParserRuleCall_0_0(), semanticObject.getGeneric_association());
		feeder.accept(grammarAccess.getGeneric_assoc_listAccess().getGeneric_assoc_list_linhaGeneric_assoc_list_linhaParserRuleCall_1_0(), semanticObject.getGeneric_assoc_list_linha());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     generic_assoc_list_linha returns GenericAssocListLinhaAction
	 *
	 * Constraint:
	 *     (generic_association=generic_association generic_assoc_list_linha=generic_assoc_list_linha)?
	 */
	protected void sequence_generic_assoc_list_linha(ISerializationContext context, GenericAssocListLinhaAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     generic_association returns generic_association
	 *
	 * Constraint:
	 *     ((type_name=type_name assignment_expression=assignment_expression) | (default='default' assignment_expression=assignment_expression))
	 */
	protected void sequence_generic_association(ISerializationContext context, generic_association semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     generic_selection returns generic_selection
	 *
	 * Constraint:
	 *     (_generic='_Generic' assignment_expression=assignment_expression generic_assoc_list+=generic_assoc_list)
	 */
	protected void sequence_generic_selection(ISerializationContext context, generic_selection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     identifier_list returns identifier_list
	 *
	 * Constraint:
	 *     (identifier=IDz identifier_list_linha=identifier_list_linha)
	 */
	protected void sequence_identifier_list(ISerializationContext context, identifier_list semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.IDENTIFIER_LIST__IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.IDENTIFIER_LIST__IDENTIFIER));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.IDENTIFIER_LIST__IDENTIFIER_LIST_LINHA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.IDENTIFIER_LIST__IDENTIFIER_LIST_LINHA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIdentifier_listAccess().getIdentifierIDzTerminalRuleCall_0_0(), semanticObject.getIdentifier());
		feeder.accept(grammarAccess.getIdentifier_listAccess().getIdentifier_list_linhaIdentifier_list_linhaParserRuleCall_1_0(), semanticObject.getIdentifier_list_linha());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     identifier_list_linha returns IdentifierListLinhaAction
	 *
	 * Constraint:
	 *     (identifier=IDz identifier_list_linha=identifier_list_linha)?
	 */
	protected void sequence_identifier_list_linha(ISerializationContext context, IdentifierListLinhaAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     inclusive_or_expression returns inclusive_or_expression
	 *
	 * Constraint:
	 *     (exclusive_or_expression=exclusive_or_expression inclusive_or_expression_linha=inclusive_or_expression_linha)
	 */
	protected void sequence_inclusive_or_expression(ISerializationContext context, inclusive_or_expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.INCLUSIVE_OR_EXPRESSION__EXCLUSIVE_OR_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.INCLUSIVE_OR_EXPRESSION__EXCLUSIVE_OR_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.INCLUSIVE_OR_EXPRESSION__INCLUSIVE_OR_EXPRESSION_LINHA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.INCLUSIVE_OR_EXPRESSION__INCLUSIVE_OR_EXPRESSION_LINHA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInclusive_or_expressionAccess().getExclusive_or_expressionExclusive_or_expressionParserRuleCall_0_0(), semanticObject.getExclusive_or_expression());
		feeder.accept(grammarAccess.getInclusive_or_expressionAccess().getInclusive_or_expression_linhaInclusive_or_expression_linhaParserRuleCall_1_0(), semanticObject.getInclusive_or_expression_linha());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     inclusive_or_expression_linha returns inclusive_or_expression_linha
	 *
	 * Constraint:
	 *     (exclusive_or_expression=exclusive_or_expression inclusive_or_expression_linha=inclusive_or_expression_linha)
	 */
	protected void sequence_inclusive_or_expression_linha(ISerializationContext context, inclusive_or_expression_linha semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.INCLUSIVE_OR_EXPRESSION_LINHA__EXCLUSIVE_OR_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.INCLUSIVE_OR_EXPRESSION_LINHA__EXCLUSIVE_OR_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.INCLUSIVE_OR_EXPRESSION_LINHA__INCLUSIVE_OR_EXPRESSION_LINHA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.INCLUSIVE_OR_EXPRESSION_LINHA__INCLUSIVE_OR_EXPRESSION_LINHA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInclusive_or_expression_linhaAccess().getExclusive_or_expressionExclusive_or_expressionParserRuleCall_1_0(), semanticObject.getExclusive_or_expression());
		feeder.accept(grammarAccess.getInclusive_or_expression_linhaAccess().getInclusive_or_expression_linhaInclusive_or_expression_linhaParserRuleCall_2_0(), semanticObject.getInclusive_or_expression_linha());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     init_declarator returns init_declarator
	 *
	 * Constraint:
	 *     ((declarator=declarator initializer=initializer) | declarator=declarator)
	 */
	protected void sequence_init_declarator(ISerializationContext context, init_declarator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     init_declarator_list returns init_declarator_list
	 *
	 * Constraint:
	 *     (init_declarator=init_declarator init_declarator_list_linha=init_declarator_list_linha)
	 */
	protected void sequence_init_declarator_list(ISerializationContext context, init_declarator_list semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.INIT_DECLARATOR_LIST__INIT_DECLARATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.INIT_DECLARATOR_LIST__INIT_DECLARATOR));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.INIT_DECLARATOR_LIST__INIT_DECLARATOR_LIST_LINHA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.INIT_DECLARATOR_LIST__INIT_DECLARATOR_LIST_LINHA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInit_declarator_listAccess().getInit_declaratorInit_declaratorParserRuleCall_0_0(), semanticObject.getInit_declarator());
		feeder.accept(grammarAccess.getInit_declarator_listAccess().getInit_declarator_list_linhaInit_declarator_list_linhaParserRuleCall_1_0(), semanticObject.getInit_declarator_list_linha());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     init_declarator_list_linha returns InitDecclaratorListLinhaAction
	 *
	 * Constraint:
	 *     (init_declarator=init_declarator init_declarator_list_linha=init_declarator_list_linha)?
	 */
	protected void sequence_init_declarator_list_linha(ISerializationContext context, InitDecclaratorListLinhaAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     initializer returns initializer
	 *
	 * Constraint:
	 *     (init_declarator_list=initializer_list | init_declarator_list=initializer_list | assignment_expression=assignment_expression)
	 */
	protected void sequence_initializer(ISerializationContext context, initializer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     initializer_list_complement returns initializer_list_complement
	 *
	 * Constraint:
	 *     ((designation=designation initializer=initializer) | initializer=initializer)
	 */
	protected void sequence_initializer_list_complement(ISerializationContext context, initializer_list_complement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     initializer_list returns initializer_list
	 *
	 * Constraint:
	 *     (
	 *         (designation=designation initializer=initializer init_declarator_list_linha=init_declarator_list_linha) | 
	 *         (initializer=initializer init_declarator_list_linha=init_declarator_list_linha)
	 *     )
	 */
	protected void sequence_initializer_list(ISerializationContext context, initializer_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     initializer_list_linha returns InitializerListLinhaAction
	 *
	 * Constraint:
	 *     (initializer_list_complement=initializer_list_complement init_declarator_list_linha=init_declarator_list_linha)?
	 */
	protected void sequence_initializer_list_linha(ISerializationContext context, InitializerListLinhaAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     iteration_statement returns iteration_statement
	 *
	 * Constraint:
	 *     (
	 *         (expression=expression statement=statement) | 
	 *         (statement=statement expression=expression) | 
	 *         (expression_statement=expression_statement expression_statement2=expression_statement statement=statement) | 
	 *         (expression_statement=expression_statement expression_statement2=expression_statement expression=expression statement=statement) | 
	 *         (declaration=declaration expression_statement=expression_statement statement=statement) | 
	 *         (declaration=declaration expression_statement=expression_statement expression=expression statement=statement)
	 *     )
	 */
	protected void sequence_iteration_statement(ISerializationContext context, iteration_statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     jump_statement returns jump_statement
	 *
	 * Constraint:
	 *     (identifier=IDz | break='break' | return_vazio='return' | (return='return' expression=expression))
	 */
	protected void sequence_jump_statement(ISerializationContext context, jump_statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     labeled_statement returns labeled_statement
	 *
	 * Constraint:
	 *     ((identifier=IDz statement=statement) | (conditional_expression=conditional_expression statement=statement) | statement=statement)
	 */
	protected void sequence_labeled_statement(ISerializationContext context, labeled_statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     logical_and_expression_linha returns logical_and_expression_linha
	 *
	 * Constraint:
	 *     (inclusive_or_expression=inclusive_or_expression logical_and_expression_linha=logical_and_expression_linha)
	 */
	protected void sequence_logical_and_expression_linha(ISerializationContext context, logical_and_expression_linha semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.LOGICAL_AND_EXPRESSION_LINHA__INCLUSIVE_OR_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.LOGICAL_AND_EXPRESSION_LINHA__INCLUSIVE_OR_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.LOGICAL_AND_EXPRESSION_LINHA__LOGICAL_AND_EXPRESSION_LINHA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.LOGICAL_AND_EXPRESSION_LINHA__LOGICAL_AND_EXPRESSION_LINHA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogical_and_expression_linhaAccess().getInclusive_or_expressionInclusive_or_expressionParserRuleCall_1_0(), semanticObject.getInclusive_or_expression());
		feeder.accept(grammarAccess.getLogical_and_expression_linhaAccess().getLogical_and_expression_linhaLogical_and_expression_linhaParserRuleCall_2_0(), semanticObject.getLogical_and_expression_linha());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     logical_and_expression returns logical_and_expression
	 *
	 * Constraint:
	 *     (inclusive_or_expression=inclusive_or_expression logical_and_expression_linha=logical_and_expression_linha)
	 */
	protected void sequence_logical_and_expression(ISerializationContext context, logical_and_expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.LOGICAL_AND_EXPRESSION__INCLUSIVE_OR_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.LOGICAL_AND_EXPRESSION__INCLUSIVE_OR_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.LOGICAL_AND_EXPRESSION__LOGICAL_AND_EXPRESSION_LINHA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.LOGICAL_AND_EXPRESSION__LOGICAL_AND_EXPRESSION_LINHA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogical_and_expressionAccess().getInclusive_or_expressionInclusive_or_expressionParserRuleCall_0_0(), semanticObject.getInclusive_or_expression());
		feeder.accept(grammarAccess.getLogical_and_expressionAccess().getLogical_and_expression_linhaLogical_and_expression_linhaParserRuleCall_1_0(), semanticObject.getLogical_and_expression_linha());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     logical_or_expression_linha returns logical_or_expression_linha
	 *
	 * Constraint:
	 *     (logical_and_expression=logical_and_expression logical_or_expression_linha=logical_or_expression_linha)
	 */
	protected void sequence_logical_or_expression_linha(ISerializationContext context, logical_or_expression_linha semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.LOGICAL_OR_EXPRESSION_LINHA__LOGICAL_AND_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.LOGICAL_OR_EXPRESSION_LINHA__LOGICAL_AND_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.LOGICAL_OR_EXPRESSION_LINHA__LOGICAL_OR_EXPRESSION_LINHA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.LOGICAL_OR_EXPRESSION_LINHA__LOGICAL_OR_EXPRESSION_LINHA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogical_or_expression_linhaAccess().getLogical_and_expressionLogical_and_expressionParserRuleCall_1_0(), semanticObject.getLogical_and_expression());
		feeder.accept(grammarAccess.getLogical_or_expression_linhaAccess().getLogical_or_expression_linhaLogical_or_expression_linhaParserRuleCall_2_0(), semanticObject.getLogical_or_expression_linha());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     logical_or_expression returns logical_or_expression
	 *
	 * Constraint:
	 *     (logical_and_expression=logical_and_expression logical_or_expression_linha=logical_or_expression_linha)
	 */
	protected void sequence_logical_or_expression(ISerializationContext context, logical_or_expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.LOGICAL_OR_EXPRESSION__LOGICAL_AND_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.LOGICAL_OR_EXPRESSION__LOGICAL_AND_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.LOGICAL_OR_EXPRESSION__LOGICAL_OR_EXPRESSION_LINHA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.LOGICAL_OR_EXPRESSION__LOGICAL_OR_EXPRESSION_LINHA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogical_or_expressionAccess().getLogical_and_expressionLogical_and_expressionParserRuleCall_0_0(), semanticObject.getLogical_and_expression());
		feeder.accept(grammarAccess.getLogical_or_expressionAccess().getLogical_or_expression_linhaLogical_or_expression_linhaParserRuleCall_1_0(), semanticObject.getLogical_or_expression_linha());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     multiplicative_expression_complement returns multiplicative_expression_complement
	 *
	 * Constraint:
	 *     ((multiplica='*' cast_expression=cast_expression) | (divide='/' cast_expression=cast_expression) | (modulo='%' cast_expression=cast_expression))
	 */
	protected void sequence_multiplicative_expression_complement(ISerializationContext context, multiplicative_expression_complement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     multiplicative_expression_linha returns multiplicative_expression_linha
	 *
	 * Constraint:
	 *     (multiplicative_expression_complement=multiplicative_expression_complement multiplicative_expression_linha=multiplicative_expression_linha)
	 */
	protected void sequence_multiplicative_expression_linha(ISerializationContext context, multiplicative_expression_linha semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.MULTIPLICATIVE_EXPRESSION_LINHA__MULTIPLICATIVE_EXPRESSION_COMPLEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.MULTIPLICATIVE_EXPRESSION_LINHA__MULTIPLICATIVE_EXPRESSION_COMPLEMENT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.MULTIPLICATIVE_EXPRESSION_LINHA__MULTIPLICATIVE_EXPRESSION_LINHA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.MULTIPLICATIVE_EXPRESSION_LINHA__MULTIPLICATIVE_EXPRESSION_LINHA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicative_expression_linhaAccess().getMultiplicative_expression_complementMultiplicative_expression_complementParserRuleCall_0_0(), semanticObject.getMultiplicative_expression_complement());
		feeder.accept(grammarAccess.getMultiplicative_expression_linhaAccess().getMultiplicative_expression_linhaMultiplicative_expression_linhaParserRuleCall_1_0(), semanticObject.getMultiplicative_expression_linha());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     multiplicative_expression returns multiplicative_expression
	 *
	 * Constraint:
	 *     (cast_expression=cast_expression multiplicative_expression_linha=multiplicative_expression_linha)
	 */
	protected void sequence_multiplicative_expression(ISerializationContext context, multiplicative_expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.MULTIPLICATIVE_EXPRESSION__CAST_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.MULTIPLICATIVE_EXPRESSION__CAST_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.MULTIPLICATIVE_EXPRESSION__MULTIPLICATIVE_EXPRESSION_LINHA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.MULTIPLICATIVE_EXPRESSION__MULTIPLICATIVE_EXPRESSION_LINHA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicative_expressionAccess().getCast_expressionCast_expressionParserRuleCall_0_0(), semanticObject.getCast_expression());
		feeder.accept(grammarAccess.getMultiplicative_expressionAccess().getMultiplicative_expression_linhaMultiplicative_expression_linhaParserRuleCall_1_0(), semanticObject.getMultiplicative_expression_linha());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     parameter_declaration returns parameter_declaration
	 *
	 * Constraint:
	 *     (
	 *         (declaration_specifiers=declaration_specifiers declarator=declarator) | 
	 *         (declaration_specifiers=declaration_specifiers abstract_declarator=abstract_declarator) | 
	 *         declaration_specifiers=declaration_specifiers
	 *     )
	 */
	protected void sequence_parameter_declaration(ISerializationContext context, parameter_declaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     parameter_list_linha returns parameter_list_linha
	 *
	 * Constraint:
	 *     (parameter_declaration=parameter_declaration parameter_list_linha+=parameter_list_linha)
	 */
	protected void sequence_parameter_list_linha(ISerializationContext context, parameter_list_linha semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     parameter_lista returns parameter_lista
	 *
	 * Constraint:
	 *     (parameter_declarations+=parameter_declaration parameter_declarations+=parameter_declaration*)
	 */
	protected void sequence_parameter_lista(ISerializationContext context, parameter_lista semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     parameter_type_list returns parameter_type_list
	 *
	 * Constraint:
	 *     (parameter_lista=parameter_lista | parameter_lista=parameter_lista)
	 */
	protected void sequence_parameter_type_list(ISerializationContext context, parameter_type_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     pointer returns pointer
	 *
	 * Constraint:
	 *     ((type_qualifier_list=type_qualifier_list pointer=pointer) | type_qualifier_list=type_qualifier_list | pointer=pointer)
	 */
	protected void sequence_pointer(ISerializationContext context, pointer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     postfix_expression_complement returns PostFixEmpryParams
	 *
	 * Constraint:
	 *     {PostFixEmpryParams}
	 */
	protected void sequence_postfix_expression_complement(ISerializationContext context, PostFixEmpryParams semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     postfix_expression_complement returns postfix_expression_complement
	 *
	 * Constraint:
	 *     (expression=expression | argument_expression_list=argument_expression_list | identifier=IDz | identifier=IDz)
	 */
	protected void sequence_postfix_expression_complement(ISerializationContext context, postfix_expression_complement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     postfix_expression_linha returns PostfixExpressionLinhaAction
	 *
	 * Constraint:
	 *     (postfix_expression_complement=postfix_expression_complement postfix_expression_linha=postfix_expression_linha)?
	 */
	protected void sequence_postfix_expression_linha(ISerializationContext context, PostfixExpressionLinhaAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     postfix_expression returns postfix_expression
	 *
	 * Constraint:
	 *     (primary_expression=primary_expression postfix_expression_linha=postfix_expression_linha)
	 */
	protected void sequence_postfix_expression(ISerializationContext context, postfix_expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.POSTFIX_EXPRESSION__PRIMARY_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.POSTFIX_EXPRESSION__PRIMARY_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.POSTFIX_EXPRESSION__POSTFIX_EXPRESSION_LINHA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.POSTFIX_EXPRESSION__POSTFIX_EXPRESSION_LINHA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPostfix_expressionAccess().getPrimary_expressionPrimary_expressionParserRuleCall_0_0_0(), semanticObject.getPrimary_expression());
		feeder.accept(grammarAccess.getPostfix_expressionAccess().getPostfix_expression_linhaPostfix_expression_linhaParserRuleCall_0_1_0(), semanticObject.getPostfix_expression_linha());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     postfix_expression returns type_name
	 *
	 * Constraint:
	 *     (
	 *         ((specifier_qualifier_list=specifier_qualifier_list abstract_declarator=abstract_declarator) | specifier_qualifier_list=specifier_qualifier_list) 
	 *         (
	 *             (initializer_list=initializer_list postfix_expression_linha=postfix_expression_linha) | 
	 *             (initializer_list=initializer_list postfix_expression_linha=postfix_expression_linha)
	 *         )
	 *     )
	 */
	protected void sequence_postfix_expression_type_name(ISerializationContext context, type_name semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     primary_expression returns primary_expression
	 *
	 * Constraint:
	 *     (identifier=IDz | constant=constant | expression=expression | generic_selection=generic_selection)
	 */
	protected void sequence_primary_expression(ISerializationContext context, primary_expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     relational_expression_complement returns relational_expression_complement
	 *
	 * Constraint:
	 *     (
	 *         (menor='<' shift_expression=shift_expression) | 
	 *         (maior='>' shift_expression=shift_expression) | 
	 *         (menor_igual='<=' shift_expression=shift_expression) | 
	 *         (maior_igual='>=' shift_expression=shift_expression)
	 *     )
	 */
	protected void sequence_relational_expression_complement(ISerializationContext context, relational_expression_complement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     relational_expression_linha returns relational_expression_linha
	 *
	 * Constraint:
	 *     (shift_expression_complement=shift_expression_complement relational_expression_linha=relational_expression_linha)
	 */
	protected void sequence_relational_expression_linha(ISerializationContext context, relational_expression_linha semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.RELATIONAL_EXPRESSION_LINHA__SHIFT_EXPRESSION_COMPLEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.RELATIONAL_EXPRESSION_LINHA__SHIFT_EXPRESSION_COMPLEMENT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.RELATIONAL_EXPRESSION_LINHA__RELATIONAL_EXPRESSION_LINHA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.RELATIONAL_EXPRESSION_LINHA__RELATIONAL_EXPRESSION_LINHA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelational_expression_linhaAccess().getShift_expression_complementShift_expression_complementParserRuleCall_0_0(), semanticObject.getShift_expression_complement());
		feeder.accept(grammarAccess.getRelational_expression_linhaAccess().getRelational_expression_linhaRelational_expression_linhaParserRuleCall_1_0(), semanticObject.getRelational_expression_linha());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     relational_expression returns relational_expression
	 *
	 * Constraint:
	 *     (shift_expression=shift_expression relational_expression_linha=relational_expression_linha)
	 */
	protected void sequence_relational_expression(ISerializationContext context, relational_expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.RELATIONAL_EXPRESSION__SHIFT_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.RELATIONAL_EXPRESSION__SHIFT_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.RELATIONAL_EXPRESSION__RELATIONAL_EXPRESSION_LINHA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.RELATIONAL_EXPRESSION__RELATIONAL_EXPRESSION_LINHA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelational_expressionAccess().getShift_expressionShift_expressionParserRuleCall_0_0(), semanticObject.getShift_expression());
		feeder.accept(grammarAccess.getRelational_expressionAccess().getRelational_expression_linhaRelational_expression_linhaParserRuleCall_1_0(), semanticObject.getRelational_expression_linha());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     selection_statement returns selection_statement
	 *
	 * Constraint:
	 *     (
	 *         (expression=expression statement=statement statement2=statement) | 
	 *         (expression=expression statement=statement) | 
	 *         (expression=expression statement=statement)
	 *     )
	 */
	protected void sequence_selection_statement(ISerializationContext context, selection_statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     shift_expression_complement returns shift_expression_complement
	 *
	 * Constraint:
	 *     ((sleft='<<' additive_expression=additive_expression) | (sright='>>' additive_expression=additive_expression))
	 */
	protected void sequence_shift_expression_complement(ISerializationContext context, shift_expression_complement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     shift_expression_linha returns shift_expression_linha
	 *
	 * Constraint:
	 *     (shift_expression_complement=shift_expression_complement shift_expression_linha=shift_expression_linha)
	 */
	protected void sequence_shift_expression_linha(ISerializationContext context, shift_expression_linha semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.SHIFT_EXPRESSION_LINHA__SHIFT_EXPRESSION_COMPLEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.SHIFT_EXPRESSION_LINHA__SHIFT_EXPRESSION_COMPLEMENT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.SHIFT_EXPRESSION_LINHA__SHIFT_EXPRESSION_LINHA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.SHIFT_EXPRESSION_LINHA__SHIFT_EXPRESSION_LINHA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getShift_expression_linhaAccess().getShift_expression_complementShift_expression_complementParserRuleCall_0_0(), semanticObject.getShift_expression_complement());
		feeder.accept(grammarAccess.getShift_expression_linhaAccess().getShift_expression_linhaShift_expression_linhaParserRuleCall_1_0(), semanticObject.getShift_expression_linha());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     shift_expression returns shift_expression
	 *
	 * Constraint:
	 *     (additive_expression=additive_expression shift_expression_linha=shift_expression_linha)
	 */
	protected void sequence_shift_expression(ISerializationContext context, shift_expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.SHIFT_EXPRESSION__ADDITIVE_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.SHIFT_EXPRESSION__ADDITIVE_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.SHIFT_EXPRESSION__SHIFT_EXPRESSION_LINHA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.SHIFT_EXPRESSION__SHIFT_EXPRESSION_LINHA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getShift_expressionAccess().getAdditive_expressionAdditive_expressionParserRuleCall_0_0(), semanticObject.getAdditive_expression());
		feeder.accept(grammarAccess.getShift_expressionAccess().getShift_expression_linhaShift_expression_linhaParserRuleCall_1_0(), semanticObject.getShift_expression_linha());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     specifier_qualifier_list returns specifier_qualifier_list
	 *
	 * Constraint:
	 *     (
	 *         (type_specifier=type_specifier specifier_qualifier_list=specifier_qualifier_list) | 
	 *         type_specifier=type_specifier | 
	 *         (type_qualifier=type_qualifier specifier_qualifier_list=specifier_qualifier_list) | 
	 *         type_qualifier=type_qualifier
	 *     )
	 */
	protected void sequence_specifier_qualifier_list(ISerializationContext context, specifier_qualifier_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     statement returns statement
	 *
	 * Constraint:
	 *     (
	 *         labeled_statement=labeled_statement | 
	 *         compound_statement=compound_statement | 
	 *         expression_statement=expression_statement | 
	 *         selection_statement=selection_statement | 
	 *         iteration_statement=iteration_statement | 
	 *         jump_statement=jump_statement
	 *     )
	 */
	protected void sequence_statement(ISerializationContext context, statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     static_assert_declaration returns static_assert_declaration
	 *
	 * Constraint:
	 *     constant_expression=constant_expression
	 */
	protected void sequence_static_assert_declaration(ISerializationContext context, static_assert_declaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.STATIC_ASSERT_DECLARATION__CONSTANT_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.STATIC_ASSERT_DECLARATION__CONSTANT_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStatic_assert_declarationAccess().getConstant_expressionConstant_expressionParserRuleCall_2_0(), semanticObject.getConstant_expression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     string_ufcg returns string_ufcg
	 *
	 * Constraint:
	 *     (string_literal=STRING_LITERAL | __func__='__func__')
	 */
	protected void sequence_string_ufcg(ISerializationContext context, string_ufcg semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     struct_declaration_list_linha returns StructDeclarationListLinhaAction
	 *
	 * Constraint:
	 *     (struct_declaration=struct_declaration struct_declaration_list_linha=struct_declaration_list_linha)?
	 */
	protected void sequence_struct_declaration_list_linha(ISerializationContext context, StructDeclarationListLinhaAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     struct_declaration_list returns struct_declaration_list
	 *
	 * Constraint:
	 *     (struct_declaration=struct_declaration struct_declaration_list_linha=struct_declaration_list_linha)
	 */
	protected void sequence_struct_declaration_list(ISerializationContext context, struct_declaration_list semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.STRUCT_DECLARATION_LIST__STRUCT_DECLARATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.STRUCT_DECLARATION_LIST__STRUCT_DECLARATION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.STRUCT_DECLARATION_LIST__STRUCT_DECLARATION_LIST_LINHA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.STRUCT_DECLARATION_LIST__STRUCT_DECLARATION_LIST_LINHA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStruct_declaration_listAccess().getStruct_declarationStruct_declarationParserRuleCall_0_0(), semanticObject.getStruct_declaration());
		feeder.accept(grammarAccess.getStruct_declaration_listAccess().getStruct_declaration_list_linhaStruct_declaration_list_linhaParserRuleCall_1_0(), semanticObject.getStruct_declaration_list_linha());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     struct_declaration returns struct_declaration
	 *
	 * Constraint:
	 *     (
	 *         specifier_qualifier_list=specifier_qualifier_list | 
	 *         (specifier_qualifier_list=specifier_qualifier_list struct_declarator_list=struct_declarator_list) | 
	 *         static_assert_declaration=static_assert_declaration
	 *     )
	 */
	protected void sequence_struct_declaration(ISerializationContext context, struct_declaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     struct_declarator_list_linha returns StructDeclaratorListLinhaAction
	 *
	 * Constraint:
	 *     (struct_declarator=struct_declarator struct_declarator_list_linha=struct_declarator_list_linha)?
	 */
	protected void sequence_struct_declarator_list_linha(ISerializationContext context, StructDeclaratorListLinhaAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     struct_declarator_list returns struct_declarator_list
	 *
	 * Constraint:
	 *     (struct_declarator=struct_declarator struct_declarator_list_linha=struct_declarator_list_linha)
	 */
	protected void sequence_struct_declarator_list(ISerializationContext context, struct_declarator_list semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.STRUCT_DECLARATOR_LIST__STRUCT_DECLARATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.STRUCT_DECLARATOR_LIST__STRUCT_DECLARATOR));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.STRUCT_DECLARATOR_LIST__STRUCT_DECLARATOR_LIST_LINHA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.STRUCT_DECLARATOR_LIST__STRUCT_DECLARATOR_LIST_LINHA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStruct_declarator_listAccess().getStruct_declaratorStruct_declaratorParserRuleCall_0_0(), semanticObject.getStruct_declarator());
		feeder.accept(grammarAccess.getStruct_declarator_listAccess().getStruct_declarator_list_linhaStruct_declarator_list_linhaParserRuleCall_1_0(), semanticObject.getStruct_declarator_list_linha());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     struct_declarator returns struct_declarator
	 *
	 * Constraint:
	 *     (constant_expression=constant_expression | (declarator=declarator constant_expression=constant_expression) | declarator=declarator)
	 */
	protected void sequence_struct_declarator(ISerializationContext context, struct_declarator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     struct_or_union_specifier_complement returns StructOrUnionSpecifierComplementAction
	 *
	 * Constraint:
	 *     struct_declaration_list=struct_declaration_list?
	 */
	protected void sequence_struct_or_union_specifier_complement(ISerializationContext context, StructOrUnionSpecifierComplementAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     struct_or_union_specifier returns struct_or_union_specifier
	 *
	 * Constraint:
	 *     (
	 *         (struct_or_union=struct_or_union struct_declaration_list=struct_declaration_list) | 
	 *         (struct_or_union=struct_or_union identifier=IDz struct_or_union_specifier_complement=struct_or_union_specifier_complement)
	 *     )
	 */
	protected void sequence_struct_or_union_specifier(ISerializationContext context, struct_or_union_specifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     translation_unit_linha returns TranlationUnitLinhaAction
	 *
	 * Constraint:
	 *     (external_declaration=external_declaration translation_unit_linha=translation_unit_linha)?
	 */
	protected void sequence_translation_unit_linha(ISerializationContext context, TranlationUnitLinhaAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     translation_unit returns translation_unit
	 *
	 * Constraint:
	 *     (external_declaration=external_declaration translation_unit_linha=translation_unit_linha)
	 */
	protected void sequence_translation_unit(ISerializationContext context, translation_unit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TRANSLATION_UNIT__EXTERNAL_DECLARATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TRANSLATION_UNIT__EXTERNAL_DECLARATION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TRANSLATION_UNIT__TRANSLATION_UNIT_LINHA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TRANSLATION_UNIT__TRANSLATION_UNIT_LINHA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTranslation_unitAccess().getExternal_declarationExternal_declarationParserRuleCall_0_0(), semanticObject.getExternal_declaration());
		feeder.accept(grammarAccess.getTranslation_unitAccess().getTranslation_unit_linhaTranslation_unit_linhaParserRuleCall_1_0(), semanticObject.getTranslation_unit_linha());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     type_name returns type_name
	 *
	 * Constraint:
	 *     ((specifier_qualifier_list=specifier_qualifier_list abstract_declarator=abstract_declarator) | specifier_qualifier_list=specifier_qualifier_list)
	 */
	protected void sequence_type_name(ISerializationContext context, type_name semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     type_qualifier_list_linha returns TypeQualifierListLinhaAtion
	 *
	 * Constraint:
	 *     (type_qualifier=type_qualifier type_qualifier_list_linha=type_qualifier_list_linha)?
	 */
	protected void sequence_type_qualifier_list_linha(ISerializationContext context, TypeQualifierListLinhaAtion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     type_qualifier_list returns type_qualifier_list
	 *
	 * Constraint:
	 *     (type_qualifier=type_qualifier type_qualifier_list_linha=type_qualifier_list_linha)
	 */
	protected void sequence_type_qualifier_list(ISerializationContext context, type_qualifier_list semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TYPE_QUALIFIER_LIST__TYPE_QUALIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TYPE_QUALIFIER_LIST__TYPE_QUALIFIER));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TYPE_QUALIFIER_LIST__TYPE_QUALIFIER_LIST_LINHA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TYPE_QUALIFIER_LIST__TYPE_QUALIFIER_LIST_LINHA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getType_qualifier_listAccess().getType_qualifierType_qualifierParserRuleCall_0_0(), semanticObject.getType_qualifier());
		feeder.accept(grammarAccess.getType_qualifier_listAccess().getType_qualifier_list_linhaType_qualifier_list_linhaParserRuleCall_1_0(), semanticObject.getType_qualifier_list_linha());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     type_qualifier returns type_qualifier
	 *
	 * Constraint:
	 *     (namez='const' | namez='restrict' | namez='volatile' | namez='_Atomic')
	 */
	protected void sequence_type_qualifier(ISerializationContext context, type_qualifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     type_specifier returns type_specifier
	 *
	 * Constraint:
	 *     (
	 *         type_name_str='void' | 
	 *         type_name_str='char' | 
	 *         type_name_str='short' | 
	 *         type_name_str='int' | 
	 *         type_name_str='long' | 
	 *         type_name_str='float' | 
	 *         type_name_str='double' | 
	 *         type_name_str='signed' | 
	 *         type_name_str='unsigned' | 
	 *         type_name_str='bool' | 
	 *         type_name_str='_Complex' | 
	 *         type_name_str='_Imaginary' | 
	 *         atomic_type_specifier=atomic_type_specifier | 
	 *         struct_or_union_specifier=struct_or_union_specifier | 
	 *         enum_specifier=enum_specifier | 
	 *         type_name_str='typedef'
	 *     )
	 */
	protected void sequence_type_specifier(ISerializationContext context, type_specifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     unary_expression returns PlusPlus
	 *
	 * Constraint:
	 *     (plus='++' unary_expression=unary_expression)
	 */
	protected void sequence_unary_expression(ISerializationContext context, PlusPlus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PLUS_PLUS__PLUS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PLUS_PLUS__PLUS));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.UNARY_EXPRESSION__UNARY_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.UNARY_EXPRESSION__UNARY_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnary_expressionAccess().getPlusPlusSignPlusSignKeyword_1_1_0(), semanticObject.getPlus());
		feeder.accept(grammarAccess.getUnary_expressionAccess().getUnary_expressionUnary_expressionParserRuleCall_1_2_0(), semanticObject.getUnary_expression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     unary_expression returns unary_expression
	 *
	 * Constraint:
	 *     (
	 *         postfix_expression=postfix_expression | 
	 *         unary_expression=unary_expression | 
	 *         (unary_operator=unary_operator cast_expression=cast_expression) | 
	 *         unary_expression=unary_expression | 
	 *         type_name=type_name | 
	 *         type_name=type_name
	 *     )
	 */
	protected void sequence_unary_expression(ISerializationContext context, unary_expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
