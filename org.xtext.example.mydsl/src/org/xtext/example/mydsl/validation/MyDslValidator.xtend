/*
 * generated by Xtext 2.13.0
 */
package org.xtext.example.mydsl.validation

import org.xtext.example.mydsl.myDsl.primary_expression
import org.eclipse.xtext.validation.Check
import org.xtext.example.mydsl.myDsl.type_specifier
import org.xtext.example.mydsl.myDsl.Model
import org.xtext.example.mydsl.myDsl.postfix_expression
import org.xtext.example.mydsl.myDsl.postfix_expression_complement
import org.xtext.example.mydsl.myDsl.translation_unit
import org.xtext.example.mydsl.myDsl.unary_expression
import org.xtext.example.mydsl.myDsl.cast_expression
import org.xtext.example.mydsl.myDsl.block_item_list
import org.xtext.example.mydsl.myDsl.jump_statement

import org.xtext.example.mydsl.myDsl.block_item_list_linha
import org.xtext.example.mydsl.myDsl.multiplicative_expression
import org.xtext.example.mydsl.myDsl.logical_or_expression
import org.xtext.example.mydsl.myDsl.inclusive_or_expression
import org.xtext.example.mydsl.myDsl.exclusive_or_expression
import org.xtext.example.mydsl.myDsl.and_expression
import org.xtext.example.mydsl.myDsl.logical_and_expression
import org.xtext.example.mydsl.myDsl.multiplicative_expression_linha	

import org.xtext.example.mydsl.myDsl.multiplicative_expression_complement
import org.xtext.example.mydsl.myDsl.additive_expression
import org.xtext.example.mydsl.myDsl.additive_expression_linha
import org.xtext.example.mydsl.myDsl.additive_expression_complement
import org.xtext.example.mydsl.myDsl.shift_expression
import org.xtext.example.mydsl.myDsl.shift_expression_linha
import org.xtext.example.mydsl.myDsl.shift_expression_complement
import org.xtext.example.mydsl.myDsl.relational_expression
import org.xtext.example.mydsl.myDsl.relational_expression_linha
import org.xtext.example.mydsl.myDsl.relational_expression_complement
import org.xtext.example.mydsl.myDsl.equality_expression
import org.xtext.example.mydsl.myDsl.equality_expression_linha
import org.xtext.example.mydsl.myDsl.equality_expression_complement
import org.xtext.example.mydsl.myDsl.additive_expression
import org.xtext.example.mydsl.myDsl.PostFixEmpryParams
import org.xtext.example.mydsl.myDsl.enum_specifier
import org.xtext.example.mydsl.myDsl.declaration
import org.xtext.example.mydsl.myDsl.primary_expression
import org.xtext.example.mydsl.myDsl.assignment_expression
import org.xtext.example.mydsl.myDsl.function_definition
import org.xtext.example.mydsl.myDsl.selection_statement
import org.xtext.example.mydsl.myDsl.iteration_statement
import org.xtext.example.mydsl.myDsl.MyDslPackage
import java.util.List
import java.util.ArrayList
import org.xtext.example.mydsl.myDsl.MyDslFactory
import org.xtext.example.mydsl.myDsl.impl.MyDslFactoryImpl
import javax.swing.text.Position.Bias

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class MyDslValidator extends AbstractMyDslValidator {
	
	public enum ExpRetType {
	  	NUMERIC,
	  	CHAR,
	  	STRING,
	  	BOOL
  	}
  	private var functions = <String, Function>newHashMap();
  	public static class Function{
  		public int param_number = 0;
  		public List<String> params_types = new ArrayList<String>();
  		public String retType;
  		public String name;
  }
  
 	@Check
	def restart(Model d){
		println("Clearing...")
		variables.clear();
		functions.clear();
	}
	
	private var variables = <String,String>newHashMap();
	
	def checkDeclarationWithConstant(String leftType, primary_expression rightType){
		if(rightType.constant.f_constant == null && rightType.constant.enumz == null && rightType.constant.char == null){
			if(leftType == "char" || leftType == 'bool' || leftType == 'void' || leftType == 'string'){
							error('Esse tipo não recebe valores numéricos', 
					MyDslPackage.Literals.DECLARATION__DECLARATION_SPECIFIERS);
			}
		}else if(rightType.constant.f_constant != null){
			if(leftType == "char" || leftType == 'bool' || leftType == 'void' || leftType == "int" || leftType == 'string'){
							error('Esse tipo não recebe valores numéricos com ponto flutuante', 
					MyDslPackage.Literals.DECLARATION__INIT_DECLARATOR_LIST);
			}
		} else if (rightType.constant.char != null) {
			if (leftType != "char" || leftType != "string" ) {
				error("Esse tipo não recebe String", MyDslPackage.Literals.DECLARATION__INIT_DECLARATOR_LIST);
			}
		}
	}
	
	@Check
	def checkDeclarationTypes(declaration decl){
		var leftType =  decl.declaration_specifiers.get(0).type_specifier.type_name_str;
		var id = decl.init_declarator_list.get(0).init_declarator.declarator.direct_declarator.identifier;
		if(variables.containsKey(id)){
			error("Variável já declarada", null);
		}
		variables.put(id, leftType);	
		if(getExpType(decl.init_declarator_list.get(0).init_declarator.initializer.assignment_expression) != null){
		
			var expType = getExpType(
			decl.init_declarator_list.get(0).init_declarator.initializer.assignment_expression);
			if (expType == ExpRetType.NUMERIC) {
				if (leftType == "bool" || leftType == 'char') {
					error(
						"Tipos incompativeis para atribuição",
						MyDslPackage.Literals.DECLARATION__INIT_DECLARATOR_LIST
					)
				}
			} else if (expType == ExpRetType.BOOL) {
				if (leftType != "bool") {
					error(
						"Não é possível atribuir retorno booleano para o tipo declarado",
						MyDslPackage.Literals.
							DECLARATION__INIT_DECLARATOR_LIST
					)
				}
			} else if (expType == ExpRetType.CHAR) {
				if (leftType != "char" || leftType != "string") {
					error(
						"Não é possível atribuir String para o tipo declarado",
						MyDslPackage.Literals.
							DECLARATION__INIT_DECLARATOR_LIST
					)
				}
			}
		}
		var rightType = decl.init_declarator_list.get(0).init_declarator.initializer.assignment_expression.conditional_expression.
							logical_or_expression.logical_and_expression.inclusive_or_expression.exclusive_or_expression.
							and_expression.equality_expression.relational_expression.shift_expression.additive_expression.
							multiplicative_expression.cast_expression.unary_expression.postfix_expression.primary_expression
		if(rightType.constant != null){
			//Validar quando declaração é com uma constant
			//int a = 3;
			checkDeclarationWithConstant(leftType, rightType);
		}else if (rightType.identifier != null && !rightType.identifier.trim.isEmpty()){
			if((variables.containsKey(rightType.identifier) || functions.containsKey(rightType.identifier)) && getExpType(decl.init_declarator_list.get(0).init_declarator.initializer.assignment_expression) == null){
				if(variables.containsKey(rightType.identifier)){
					//Se for um id...
					var varType = variables.get(rightType.identifier);
					if(varType != leftType){
						error("Tipos não compatíveis",
							MyDslPackage.Literals.DECLARATION__INIT_DECLARATOR_LIST
						)
					}
				}else if(functions.containsKey(rightType.identifier)){
					//Se for uma função
					var retType = functions.get(rightType.identifier).retType;
					if(retType != leftType){
						error("Retorno de função não compativel com tipo de variavel",
							MyDslPackage.Literals.DECLARATION__INIT_DECLARATOR_LIST
						)
					}
				}
				var rType = variables.get(rightType.identifier);
				if(leftType == 'enum' && rightType!='enum'){
					error("A variavel deve ser um enum",
						MyDslPackage.Literals.DECLARATION__INIT_DECLARATOR_LIST
					)
				}				
			}else{
			}
			//Validar quando é declaração que inicia com um id
			// int a = b;
		}else if (rightType.expression != null){
			//Validar quando é declaração com uma expressão
			//int a = b+c;
		}

	}
	def static getExpType(assignment_expression exp){
		var current = exp.conditional_expression;
		if(current.conditional_expression_linha != null){
			return ExpRetType.BOOL;
		}
		var current2 = current.logical_or_expression;
		if(current2.logical_or_expression_linha != null){
			return ExpRetType.BOOL;
		}
		var current3 = current2.logical_and_expression;
		if(current3.logical_and_expression_linha != null){
			return ExpRetType.BOOL;
		}
		var current4 = current3.inclusive_or_expression;
		if(current4.inclusive_or_expression_linha != null){
			return ExpRetType.BOOL;
		}
		var current5 = current4.exclusive_or_expression;
		if(current5.exclusive_or_expression_linha != null){
			return ExpRetType.BOOL;
		}
		var current6 = current5.and_expression;
		if(current6.and_expression_linha != null){
			return ExpRetType.BOOL;
		}
		var current7 = current6.equality_expression;
		if(current7.equality_expression_linha != null){
			return ExpRetType.BOOL;
		}
		var current8 = current7.relational_expression;
		if(current8.relational_expression_linha != null){
			return ExpRetType.BOOL;
		}
		var current9 = current8.shift_expression;
		if(current9.shift_expression_linha != null){
			return ExpRetType.NUMERIC;
		}
		var current10 = current9.additive_expression;
		if(current10.additive_expression_linha != null){
			println("MAIS1: " + current10.additive_expression_linha.additive_expression_complement.mais);
			println("MENOS1: " + current10.additive_expression_linha.additive_expression_complement.menos);
			return ExpRetType.NUMERIC;
		}
		var curent11 = current10.multiplicative_expression;
		if(curent11.multiplicative_expression_linha != null){
			return ExpRetType.NUMERIC;
		}
		return null;		
	}
	  public static val INVALID_NAME = 'invalidName'
	
	@Check
	def validateFunctionReturn(jump_statement ret){
		if(ret.expression != null){
			var current = ret.eContainer();
            while(current != null && !(current instanceof function_definition)){
                current = current.eContainer();
            }
            if(current instanceof function_definition){
                var func = current as function_definition;
                var argType = func.declaration_specifiers.get(0).type_specifier.type_name_str;
                if(argType != "void"){
                	var arg = ret.expression.assignment_expression;
                	if(getExpType(arg) != null){
						var expRet = getExpType(arg);
						if(expRet == ExpRetType.NUMERIC){
							if(argType == 'bool'){
								error("Tipo de parametro não compativel",
									null
								)
							}
						}else if(expRet == ExpRetType.BOOL){
							if(argType != 'bool'){
								error("Tipo de parametro não compativel",
									null
								)
							}
						}
					}else{
						println("Is an contant or id")
						var idOrCons = primaryExpFromAssigExp(arg);
						if(idOrCons.identifier != null && !idOrCons.identifier.trim().isEmpty()){
							if(variables.containsKey(idOrCons.identifier)){
								//é UMA VARIAAVEL
								if(variables.get(idOrCons.identifier) != argType){
									error("Retorno não compatível",
										null
									)
								}
							}else if( functions.containsKey(idOrCons.identifier)){
								if(functions.get(idOrCons.identifier).retType != argType){
									error("Retorno não compatíve",
										null
									)
								}
							}
						}
						if(idOrCons.constant != null && idOrCons.constant.char != null && argType != 'char'){
							error("Retorno não compatíve",
									null
							)
						}
						//O argumento é uma contante ou um id
					}
                }
            }
		}
	}
	
	@Check
	def checkForEmptyParamFunc(PostFixEmpryParams call){
		var parent = call.eContainer().eContainer() as postfix_expression;
		var name = parent.primary_expression.identifier;
		if(!functions.containsKey(name)){
			error("Função não definida",
				null
			)
		}else{
			var func = functions.get(name);
			if(func.param_number != 0){
				error("Numero de parametros incompativeis",
					null
				)
			}
		}
	}
	
	def primaryExpFromAssigExp(assignment_expression exp){
		var ret = exp.conditional_expression.
		logical_or_expression.logical_and_expression.inclusive_or_expression.exclusive_or_expression.
		and_expression.equality_expression.relational_expression.shift_expression.additive_expression.
		multiplicative_expression.cast_expression.unary_expression.postfix_expression.primary_expression;
		return ret;
	}
	def t(){
		if(true){
			return 3
		}else{
			return "oia"
		}
	}
	

	    @Check
    def checkBlockItemList(block_item_list item){
        if(item.block_item_list_linha.isEmpty()){
            //função de uma linha
            //Final na função
            var current = item.eContainer();
            while(current != null && !(current instanceof function_definition || current instanceof selection_statement)){
                current = current.eContainer();
            }
            if(current instanceof function_definition){
                println("Achou funcao2...");
                var func = current as function_definition;
                var retType = func.declaration_specifiers.get(0).type_specifier.type_name_str;
                if(retType != "void"){
                    if(item.block_item.statement == null || item.block_item.statement.jump_statement == null
                        || item.block_item.statement.jump_statement.expression == null
                    ){
                        error("Falta o return", null);
                    }
                }
            }
        }    
    }
    
    @Check
    def checkBlockItemListLinha(block_item_list_linha item){
        println("Sem instancia...");
        if(item.block_item_list_linha.isEmpty()){
            println("Iniciando checagem...");
            var current = item.eContainer();
            while(current != null && !(current instanceof function_definition || current instanceof selection_statement)){
                current = current.eContainer();
            }
            println("Achou funcao...");
            if(current instanceof function_definition){
                println("Achou funcao2...");
                var func = current as function_definition;
                var retType = func.declaration_specifiers.get(0).type_specifier.type_name_str;
                if(retType != "void"){
                    if((item.block_item.statement == null || item.block_item.statement.jump_statement == null
                        || item.block_item.statement.jump_statement.expression == null)
                    ){
                        error("Falta o return", null);
                    }
                }
            }
            //Final na função
        }    
    }
	
	def evaluateExp(primary_expression primatyExp){
		if(primatyExp.expression == null){
			if(primatyExp.identifier != null && !primatyExp.identifier.trim().isEmpty()){
				if(!variables.containsKey(primatyExp.identifier)){
					error("Variavel não declarada", null);
					return ExpRetType.NUMERIC;
				}
				var varType = variables.get(primatyExp.identifier);
				if(varType.equals('char')){
					return ExpRetType.CHAR;
				}else{
					return ExpRetType.NUMERIC;
				}
			}
			if(primatyExp.constant.char != null && !primatyExp.constant.char.trim().isEmpty()){
				return ExpRetType.CHAR;
			}
			return ExpRetType.NUMERIC;
		}else{			
			return getExpType(primatyExp.expression.assignment_expression);
		}
	}
	
	@Check
	def CheckAndExpExp(and_expression andExp){
		if(andExp.and_expression_linha != null){
			var currentExp = andExp.equality_expression.relational_expression.shift_expression.additive_expression.multiplicative_expression.cast_expression.unary_expression.postfix_expression.primary_expression;
			var lType = evaluateExp(currentExp);			
			if(lType != ExpRetType.BOOL){
				error("Expressão E não pode operar em cima deste tipo", 
					MyDslPackage.Literals.AND_EXPRESSION__EQUALITY_EXPRESSION
				);
			}												
			var rSide = andExp.and_expression_linha.equality_expression.relational_expression.shift_expression.additive_expression.multiplicative_expression.cast_expression.unary_expression.postfix_expression.primary_expression;
			var rType = evaluateExp(rSide);
			if(rType != ExpRetType.BOOL){
				error("Expressão E pode operar em cima deste tipo", 
					MyDslPackage.Literals.AND_EXPRESSION__AND_EXPRESSION_LINHA
				);
			}
			if(rType != lType){
				error("Tipos incompativeis na operação aditiva",
					null
				)
			}
		}
	}
	
		@Check
	def CheckRelationalExp(relational_expression relExp){
		if(relExp.relational_expression_linha!= null){
			var currentExp = relExp.shift_expression.additive_expression.multiplicative_expression.cast_expression.unary_expression.postfix_expression.primary_expression;
			var lType = evaluateExp(currentExp);			
			if(lType == ExpRetType.BOOL){
				error("Expressão relacional não pode operar em cima deste tipo", 
					null
				);
			}												
			var rSide = relExp.relational_expression_linha.shift_expression_complement.additive_expression.multiplicative_expression.cast_expression.unary_expression.postfix_expression.primary_expression;
			var rType = evaluateExp(rSide);
			if(rType == ExpRetType.BOOL){
				error("Expressão relacional pode operar em cima deste tipo", 
					MyDslPackage.Literals.RELATIONAL_EXPRESSION__RELATIONAL_EXPRESSION_LINHA
				);
			}
			if(rType != lType){
				error("Tipos incompativeis na operação aditiva",
					null
				)
			}
		}
	}

	@Check
	def CheckExclusiveOrExp(exclusive_or_expression orExp){
		if(orExp.exclusive_or_expression_linha != null){
			var currentExp = orExp.and_expression.equality_expression.relational_expression.shift_expression.additive_expression.multiplicative_expression.cast_expression.unary_expression.postfix_expression.primary_expression;
			var lType = evaluateExp(currentExp);			
			if(lType != ExpRetType.BOOL){
				error("Expressão ou exclusivo pode operar em cima deste tipo", 
					MyDslPackage.Literals.EXCLUSIVE_OR_EXPRESSION__AND_EXPRESSION
				);
			}												
			var rSide = orExp.exclusive_or_expression_linha.and_expression.equality_expression.relational_expression.shift_expression.additive_expression.multiplicative_expression.cast_expression.unary_expression.postfix_expression.primary_expression;
			var rType = evaluateExp(rSide);
			if(rType != ExpRetType.BOOL){
				error("Expressão ou exclusivo pode operar em cima deste tipo", 
					MyDslPackage.Literals.EXCLUSIVE_OR_EXPRESSION__EXCLUSIVE_OR_EXPRESSION_LINHA
				);
			}
			if(rType != lType){
				error("Tipos incompativeis na operação aditiva",
					null
				)
			}
		}
	}

	@Check
	def CheckInclusiveOrExp(inclusive_or_expression orExp){
		if(orExp.inclusive_or_expression_linha != null){
			var currentExp = orExp.exclusive_or_expression.and_expression.equality_expression.relational_expression.shift_expression.additive_expression.multiplicative_expression.cast_expression.unary_expression.postfix_expression.primary_expression;
			var lType = evaluateExp(currentExp);			
			if(lType != ExpRetType.BOOL){
				error("Expressão ou inclusivo pode operar em cima deste tipo", 
					MyDslPackage.Literals.INCLUSIVE_OR_EXPRESSION__EXCLUSIVE_OR_EXPRESSION
				);
			}												
			var rSide = orExp.inclusive_or_expression_linha.exclusive_or_expression.and_expression.equality_expression.relational_expression.shift_expression.additive_expression.multiplicative_expression.cast_expression.unary_expression.postfix_expression.primary_expression;
			var rType = evaluateExp(rSide);
			if(rType != ExpRetType.BOOL){
				error("Expressão ou inclusivo pode operar em cima deste tipo", 
					MyDslPackage.Literals.INCLUSIVE_OR_EXPRESSION__INCLUSIVE_OR_EXPRESSION_LINHA
				);
			}
			if(rType != lType){
				error("Tipos incompativeis na operação aditiva",
					null
				)
			}
		}
	}

	@Check
	def CheckLogicalAndExp(logical_and_expression andExp){
		if(andExp.logical_and_expression_linha != null){
			var currentExp = andExp.inclusive_or_expression.exclusive_or_expression.and_expression.equality_expression.relational_expression.shift_expression.additive_expression.multiplicative_expression.cast_expression.unary_expression.postfix_expression.primary_expression;
			var lType = evaluateExp(currentExp);
			if(lType != ExpRetType.BOOL){
				error("Expressão E lógico pode operar em cima deste tipo", 
					MyDslPackage.Literals.LOGICAL_AND_EXPRESSION__INCLUSIVE_OR_EXPRESSION
				);
			}						
			var rSide = andExp.logical_and_expression_linha.inclusive_or_expression.exclusive_or_expression.and_expression.equality_expression.relational_expression.shift_expression.additive_expression.multiplicative_expression.cast_expression.unary_expression.postfix_expression.primary_expression;
			var rType = evaluateExp(rSide);
			if(rType != ExpRetType.BOOL){
				error("Expressão E lógico pode operar em cima deste tipo", 
					MyDslPackage.Literals.LOGICAL_AND_EXPRESSION__LOGICAL_AND_EXPRESSION_LINHA
				);
			}
			if(rType != lType){
				error("Tipos incompativeis na operação aditiva",
					null
				)
			}
		}
	}
	
	@Check
	def CheckLogicalOrExp(logical_or_expression orExp){
		if(orExp.logical_or_expression_linha != null){
			var currentExp = orExp.logical_and_expression.inclusive_or_expression.exclusive_or_expression.and_expression.equality_expression.relational_expression.shift_expression.additive_expression.multiplicative_expression.cast_expression.unary_expression.postfix_expression.primary_expression;
			var lType = evaluateExp(currentExp);
			if(lType != ExpRetType.BOOL){
				error("Expressão ou lógico pode operar em cima deste tipo", 
					MyDslPackage.Literals.LOGICAL_OR_EXPRESSION__LOGICAL_AND_EXPRESSION
				);
			}
			
			var rSide = orExp.logical_or_expression_linha.logical_and_expression.inclusive_or_expression.exclusive_or_expression.and_expression.equality_expression.relational_expression.shift_expression.additive_expression.multiplicative_expression.cast_expression.unary_expression.postfix_expression.primary_expression;
			var rType = evaluateExp(rSide);
			if(rType != ExpRetType.BOOL){
				error("Expressão ou lógico pode operar em cima deste tipo", 
					MyDslPackage.Literals.LOGICAL_OR_EXPRESSION__LOGICAL_OR_EXPRESSION_LINHA
				);
			}
			if(rType != lType){
				error("Tipos incompativeis na operação aditiva",
					null
				)
			}
		}
	}
	
	@Check
	def CheckAdditiveExp(additive_expression addExp){
		if(addExp.additive_expression_linha != null){
			var currentExp = addExp.multiplicative_expression.cast_expression.unary_expression.postfix_expression.primary_expression;
			var lType = evaluateExp(currentExp);
			if(lType == ExpRetType.BOOL){
				error("Expressão aditiva pode operar em cima deste tipo", 
					MyDslPackage.Literals.ADDITIVE_EXPRESSION__MULTIPLICATIVE_EXPRESSION
				);
			}
			
			var rSide = addExp.additive_expression_linha.additive_expression_complement.multiplicative_expression.cast_expression.unary_expression.postfix_expression.primary_expression;
			var rType = evaluateExp(rSide);
			if(rType == ExpRetType.BOOL){
				error("Expressão aditiva pode operar em cima deste tipo", 
					MyDslPackage.Literals.ADDITIVE_EXPRESSION__ADDITIVE_EXPRESSION_LINHA
				);
			}
			if(rType != lType){
				error("Tipos incompativeis na operação aditiva",
					null
				)
			}
		}
	}
	
	@Check
	def CheckShiftExp(shift_expression shiftExp){
		if(shiftExp.shift_expression_linha != null){
			var currentExp = shiftExp.additive_expression.multiplicative_expression.cast_expression.unary_expression.postfix_expression.primary_expression;
			var lType = evaluateExp(currentExp);
			if(lType == ExpRetType.BOOL){
				error("Expressão aditiva pode operar em cima deste tipo", 
					MyDslPackage.Literals.SHIFT_EXPRESSION__ADDITIVE_EXPRESSION
				);
			}
			
			var rSide = shiftExp.shift_expression_linha.shift_expression_complement.additive_expression.multiplicative_expression.cast_expression.unary_expression.postfix_expression.primary_expression;
			var rType = evaluateExp(rSide);
			if(rType == ExpRetType.BOOL){
				error("Expressão aditiva pode operar em cima deste tipo", 
					MyDslPackage.Literals.SHIFT_EXPRESSION__SHIFT_EXPRESSION_LINHA
				);
			}
			if(rType != lType){
				error("Tipos incompativeis na operação aditiva",
					null
				)
			}
		}
	}
	
	@Check
	def CheckMultiplicativeExp(multiplicative_expression mulExp){
		if(mulExp.multiplicative_expression_linha != null){
			var currentExp = mulExp.cast_expression.unary_expression.postfix_expression.primary_expression;
			var lType = evaluateExp(currentExp);
			if(lType == ExpRetType.BOOL){
				error("Expressão multiplicativa não pode operar em cima deste tipo", 
					MyDslPackage.Literals.MULTIPLICATIVE_EXPRESSION__CAST_EXPRESSION
				);
			}
			
			var rSide = mulExp.multiplicative_expression_linha.multiplicative_expression_complement.cast_expression.unary_expression.postfix_expression.primary_expression;
			var rType = evaluateExp(rSide);
			if(rType == ExpRetType.BOOL){
				error("Expressão multiplicativa pode operar em cima deste tipo", 
					MyDslPackage.Literals.MULTIPLICATIVE_EXPRESSION__MULTIPLICATIVE_EXPRESSION_LINHA
				);
			}
			if(rType != lType){
				error("Tipos incompativeis na operação multiplicativa",
					null
				)
			}
		}
	}
	
	@Check
	def checkFunctionCall(postfix_expression_complement call){
		var parent = call.eContainer().eContainer() as postfix_expression;
		var name = parent.primary_expression.identifier;
		if(!functions.containsKey(name)){
			error("Função não definida",
				null
			)
		}else{
			var func = functions.get(name);
			println("Checking params for: " + func.name + " With: " + func.params_types.size() + " params.")
			if(func.param_number != call.argument_expression_list.assignment_expressions.size()){
				error("Numero de parametros incompativeis",
					MyDslPackage.Literals.POSTFIX_EXPRESSION_COMPLEMENT__ARGUMENT_EXPRESSION_LIST
				)
			}else{
				for(var i = 0; i < call.argument_expression_list.assignment_expressions.size(); i++){
					var arg = call.argument_expression_list.assignment_expressions.get(i);
					println("Size: " + call.argument_expression_list.assignment_expressions.size());
					println("For: " + i);
					var argType = func.params_types.get(i);
					if(getExpType(arg) != null){
						println("Is an expression");
						var expRet = getExpType(arg);
						if(expRet == ExpRetType.NUMERIC){
							if(argType == 'bool'){
								error("Tipo de parametro não compativel",
									MyDslPackage.Literals.POSTFIX_EXPRESSION_COMPLEMENT__ARGUMENT_EXPRESSION_LIST
								)
							}
						}else if(expRet == ExpRetType.BOOL){
							if(argType != 'bool'){
								error("Tipo de parametro não compativel",
									MyDslPackage.Literals.POSTFIX_EXPRESSION_COMPLEMENT__ARGUMENT_EXPRESSION_LIST
								)
							}
						}
					}else{
						println("Is an contant or id")
						var idOrCons = primaryExpFromAssigExp(arg);
						println("CP1");
						if(idOrCons.identifier != null && !idOrCons.identifier.trim().isEmpty()){
							println("CP2");
							if(variables.containsKey(idOrCons.identifier)){
								//é UMA VARIAAVEL
								if(variables.get(idOrCons.identifier) != argType){
									println("CP3");
									error("Tipo de parametro não compativel",
										MyDslPackage.Literals.POSTFIX_EXPRESSION_COMPLEMENT__ARGUMENT_EXPRESSION_LIST
									)
								}
							}else if( functions.containsKey(idOrCons.identifier)){
								if(functions.get(idOrCons.identifier).retType != argType){
									error("Tipo de parametro não compativel",
										MyDslPackage.Literals.POSTFIX_EXPRESSION_COMPLEMENT__ARGUMENT_EXPRESSION_LIST
									)
								}
							}
						}
						println("CP4");
						if(idOrCons.constant != null && idOrCons.constant.char != null && argType != 'char'){
							println("CP5");
							error("Tipo de parametro não com 	pativel",
									MyDslPackage.Literals.POSTFIX_EXPRESSION_COMPLEMENT__ARGUMENT_EXPRESSION_LIST
							)
						}
						println("CP7");
						//O argumento é uma contante ou um id
					}
					println("End of iteration");
					//Validating params
					//call.argument_expression_list.get(i)
				}
				println("For ended");
			}
		}
		
	}
	
	@Check
	def checkPrimaryExpression(primary_expression exp){
		if(exp.identifier != null && !exp.identifier.trim().isEmpty()){
			if(!variables.containsKey(exp.identifier) && !functions.containsKey(exp.identifier)){
				error("Variavel não declarada",
					MyDslPackage.Literals.PRIMARY_EXPRESSION__IDENTIFIER
				)
			}			
		}
	}
	
	def validateActribWithId(String idLeft, String idRight){
			if(!variables.keySet.contains(idRight)){
				error('Variavel não declarada',
					MyDslPackage.Literals.ASSIGNMENT_EXPRESSION__ASSIGNMENT_EXPRESSION
				);
			}			
			var tr = variables.get(idRight);
			var tl = variables.get(idLeft);		
			validateAlarg(tr,tl);
	}
	
	
	@Check 
	def checkEnumValid(enum_specifier enumz){
		if(enumz.identifier != null){
			if(variables.containsKey(enumz.identifier)){
				error("Variável já declarada", 
					MyDslPackage.Literals.ENUM_SPECIFIER__IDENTIFIER
				);
			}else{
				variables.put(enumz.identifier, 'enum');	
			}			
		}
	}
	@Check
	def checkAtribType(assignment_expression asexp){		
		var idLeft = asexp.unary_expression.postfix_expression.primary_expression.identifier;
		var argType = variables.get(idLeft);
		if(!variables.keySet.contains(idLeft)){
			error('Variavel não declarada',
				MyDslPackage.Literals.ASSIGNMENT_EXPRESSION__UNARY_EXPRESSION
			);
		}
		if(asexp.assignment_expression != null && getExpType(asexp.assignment_expression) != null){
			var arg = asexp.assignment_expression;
			println("Is an expressionz");
			var expRet = getExpType(arg);
			if(expRet == ExpRetType.NUMERIC){
				if(argType == 'bool'){
					error("Variavel não compativel com este tipo",
						null
					)
				}
			}else if(expRet == ExpRetType.BOOL){
				if(argType != 'bool'){
					error("Tipo de parametro não compativel",
						null
					)
				}
			}
		}else{
			println("Eh um id oyu consz")
			var idOrCons = primaryExpFromAssigExp(asexp.assignment_expression);
			if(idOrCons.identifier != null && !idOrCons.identifier.trim().isEmpty()){
				if(variables.containsKey(idOrCons.identifier)){
					//é UMA VARIAAVEL
					if(variables.get(idOrCons.identifier) != argType){						
						error("Variavel não compativel com este tipo",
							null
						)
					}
				}else if( functions.containsKey(idOrCons.identifier)){
					if(functions.get(idOrCons.identifier).retType != argType){
						error("Variavel não compativel com este tipo",
							null
						)
					}
				}
			}			
			if(idOrCons.constant != null && idOrCons.constant.char != null && argType != 'char'){				
				error("Variavel não compativel com este tipo",
						null
				)
			}		
			//O argumento é uma contante ou um id
		}
	}
	
	def validateAlarg(String tr, String tl){
		if(tl == "int" && tr=="float"){
				error('Tipos incompativeis, De float para int',
					MyDslPackage.Literals.ASSIGNMENT_EXPRESSION__UNARY_EXPRESSION
				);
			}
			if(tl == "int" && tr=="double"){
				error('Tipos incompativeis, De double para int',
					MyDslPackage.Literals.ASSIGNMENT_EXPRESSION__UNARY_EXPRESSION
				);
			}
			if(tl == "short" && tr=="float"){
				error('Tipos incompativeis, De float para short',
					MyDslPackage.Literals.ASSIGNMENT_EXPRESSION__UNARY_EXPRESSION
				);
			}
			if(tl == "short" && tr=="double"){
				error('Tipos incompativeis, De double para short',
					MyDslPackage.Literals.ASSIGNMENT_EXPRESSION__UNARY_EXPRESSION
				);
			}
			if(tl == "long" && tr=="float"){
				error('Tipos incompativeis, De float para long',
					MyDslPackage.Literals.ASSIGNMENT_EXPRESSION__UNARY_EXPRESSION
				);
			}
			if(tl == "long" && tr=="double"){
				error('Tipos incompativeis, De double para long',
					MyDslPackage.Literals.ASSIGNMENT_EXPRESSION__UNARY_EXPRESSION
				);
			}
			if(tl == "int" && tr=="long"){
				error('Tipos incompativeis, De int para long',
					MyDslPackage.Literals.ASSIGNMENT_EXPRESSION__UNARY_EXPRESSION
				);
			}
			if(tl == "signed" && tr=="unsigned"){
				error('Tipos unsigned, De long para signed',
					MyDslPackage.Literals.ASSIGNMENT_EXPRESSION__UNARY_EXPRESSION
				);
			}
			if(tl == "unsigned" && tr=="signed"){
				error('Tipos incompativeis, De unsigned para signed',
					MyDslPackage.Literals.ASSIGNMENT_EXPRESSION__UNARY_EXPRESSION
				);
			}	
	}
	
	@Check
	def checkFunctionDefinition(function_definition func_decl){
		//Não tem parametros
		var f = new Function();		
		if(func_decl.declarator.direct_declarator.direct_declarator_linha.direct_declarator_complemento == null){
			f.retType = func_decl.declaration_specifiers.get(0).type_specifier.type_name_str;
			f.name = func_decl.declarator.direct_declarator.identifier.toString();
			f.param_number = 0;
			println("Inserting function... " + f.name + "With 0 params");
			functions.put(f.name, f);
		}else{
			f.retType = func_decl.declaration_specifiers.get(0).type_specifier.type_name_str;
			f.name = func_decl.declarator.direct_declarator.identifier.toString();
			var params = func_decl.declarator.direct_declarator.direct_declarator_linha.direct_declarator_complemento.parameter_type_list.parameter_lista.parameter_declarations;
			f.param_number = params.size;		
			for(var i = 0; i< f.param_number; i++){
				var decl = params.get(i);
				f.params_types.add(decl.declaration_specifiers.type_specifier.type_name_str);
				
				variables.put(decl.declarator.direct_declarator.identifier, decl.declaration_specifiers.type_specifier.type_name_str);
			}
			println("Inserting function... " + f.name + "with " + f.param_number + " params");
			functions.put(f.name, f);
			//println( "size:" + func_decl.declarator.direct_declarator.direct_declarator_linha.direct_declarator_complemento.parameter_type_list.parameter_list.get(0));
		}
	@Check
	def checkWhile(iteration_statement ite_stmt){
		if (getExpType(ite_stmt.expression.assignment_expression.assignment_expression) != ExpRetType.BOOL){
			error("Expressão booleana esperada", MyDslPackage.Literals.ITERATION_STATEMENT__EXPRESSION_STATEMENT);
		}
		ite_stmt.statement.compound_statement;
	}
		
	}

//	public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					MyDslPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}
