/*
 * generated by Xtext 2.13.0
 */
package org.xtext.example.mydsl.validation

import org.xtext.example.mydsl.myDsl.primary_expression
import org.eclipse.xtext.validation.Check
import org.xtext.example.mydsl.myDsl.type_specifier
import org.xtext.example.mydsl.myDsl.Model
import org.xtext.example.mydsl.myDsl.postfix_expression
import org.xtext.example.mydsl.myDsl.postfix_expression_complement
import org.xtext.example.mydsl.myDsl.translation_unit
import org.xtext.example.mydsl.myDsl.unary_expression
import org.xtext.example.mydsl.myDsl.cast_expression
import org.xtext.example.mydsl.myDsl.block_item_list
import org.xtext.example.mydsl.myDsl.jump_statement

import org.xtext.example.mydsl.myDsl.block_item_list_linha
import org.xtext.example.mydsl.myDsl.multiplicative_expression
import org.xtext.example.mydsl.myDsl.logical_or_expression
import org.xtext.example.mydsl.myDsl.inclusive_or_expression
import org.xtext.example.mydsl.myDsl.exclusive_or_expression
import org.xtext.example.mydsl.myDsl.and_expression
import org.xtext.example.mydsl.myDsl.logical_and_expression
import org.xtext.example.mydsl.myDsl.multiplicative_expression_linha	

import org.xtext.example.mydsl.myDsl.multiplicative_expression_complement
import org.xtext.example.mydsl.myDsl.additive_expression
import org.xtext.example.mydsl.myDsl.additive_expression_linha
import org.xtext.example.mydsl.myDsl.additive_expression_complement
import org.xtext.example.mydsl.myDsl.shift_expression
import org.xtext.example.mydsl.myDsl.shift_expression_linha
import org.xtext.example.mydsl.myDsl.shift_expression_complement
import org.xtext.example.mydsl.myDsl.relational_expression
import org.xtext.example.mydsl.myDsl.relational_expression_linha
import org.xtext.example.mydsl.myDsl.relational_expression_complement
import org.xtext.example.mydsl.myDsl.equality_expression
import org.xtext.example.mydsl.myDsl.equality_expression_linha
import org.xtext.example.mydsl.myDsl.equality_expression_complement
import org.xtext.example.mydsl.myDsl.additive_expression
import org.xtext.example.mydsl.myDsl.PostFixEmpryParams
import org.xtext.example.mydsl.myDsl.enum_specifier
import org.xtext.example.mydsl.myDsl.declaration
import org.xtext.example.mydsl.myDsl.primary_expression
import org.xtext.example.mydsl.myDsl.assignment_expression
import org.xtext.example.mydsl.myDsl.function_definition
import org.xtext.example.mydsl.myDsl.selection_statement
import org.xtext.example.mydsl.myDsl.MyDslPackage
import java.util.List
import java.util.ArrayList
import org.xtext.example.mydsl.myDsl.MyDslFactory
import org.xtext.example.mydsl.myDsl.impl.MyDslFactoryImpl
import javax.swing.text.Position.Bias

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class MyDslValidator extends AbstractMyDslValidator {
	
	public enum ExpRetType {
	  	NUMERIC,
	  	CHAR,
	  	STRING,
	  	BOOL
  	}
  	private var functions = <String, Function>newHashMap();
  	public static class Function{
  		public int param_number = 0;
  		public List<String> params_types = new ArrayList<String>();
  		public String retType;
  		public String name;
  }
  
 	@Check
	def restart(Model d){
		println("Clearing...")
		variables.clear();
		functions.clear();
	}
  
//	public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					MyDslPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}
	private var variables = <String,String>newHashMap();
	
	def checkDeclarationWithConstant(String leftType, primary_expression rightType){
		if(rightType.constant.f_constant == null && rightType.constant.enumz == null && rightType.constant.char == null && rightType.constant.string == null){
			System.out.println("RT -> null");
			if(leftType == "char" || leftType == 'bool' || leftType == 'void' || leftType == "string"){
							error('Esse tipo não recebe valores numéricos', 
					MyDslPackage.Literals.DECLARATION__DECLARATION_SPECIFIERS);
			}
		} else if(rightType.constant.f_constant != null){
			System.out.println("RT -> Float");
			if(leftType == "char" || leftType == 'bool' || leftType == 'void' || leftType == "int" || leftType == "string"){
							error('Esse tipo não recebe valores numéricos com ponto flutuante', 
					MyDslPackage.Literals.DECLARATION__INIT_DECLARATOR_LIST);
			}
		} else if (rightType.constant.char != null) {
			System.out.println("RT -> Char");
			if (leftType == "int" || leftType == "float") {
				error("Esse tipo não recebe char", MyDslPackage.Literals.DECLARATION__INIT_DECLARATOR_LIST);
			}
		} else if (rightType.constant.string != null) {
			System.out.println("RT -> String");
			if (leftType == "int" || leftType == "float" || leftType == "char") {
				error("Esse tipo não recebe string", MyDslPackage.Literals.DECLARATION__INIT_DECLARATOR_LIST);
			}
		}
	}
	
	@Check
	def checkDeclarationTypes(declaration decl){
		var leftType =  decl.declaration_specifiers.get(0).type_specifier.type_name_str;
		var id = decl.init_declarator_list.get(0).init_declarator.declarator.direct_declarator.identifier;
		if(variables.containsKey(id)){
			error("Variável já declarada", null);
		}
		variables.put(id, leftType);	
		if(getExpType(decl.init_declarator_list.get(0).init_declarator.initializer.assignment_expression) != null){
		
			var expType = getExpType(
			decl.init_declarator_list.get(0).init_declarator.initializer.assignment_expression);
			if (expType == ExpRetType.NUMERIC) {
				if (leftType == "bool" || leftType == 'char' || leftType == "string") {
					error(
						"Tipos incompativeis para atribuição",
						MyDslPackage.Literals.DECLARATION__INIT_DECLARATOR_LIST
					)
				}
			} else if (expType == ExpRetType.BOOL) {
				if (leftType != "bool") {
					error(
						"Não é possível atribuir retorno booleano para o tipo declarado",
						MyDslPackage.Literals.DECLARATION__INIT_DECLARATOR_LIST
					)
				}
			} else if (expType == ExpRetType.STRING) {
				System.out.println("expType -> String");
				if (leftType == "float" || leftType == "int" || leftType == "char") {
					error("Esse tipo não recebe string", 
						MyDslPackage.Literals.DECLARATION__INIT_DECLARATOR_LIST
					)
				}
			}
		}
		
		var rightType = decl.init_declarator_list.get(0).init_declarator.initializer.assignment_expression.conditional_expression.
							logical_or_expression.logical_and_expression.inclusive_or_expression.exclusive_or_expression.
							and_expression.equality_expression.relational_expression.shift_expression.additive_expression.
							multiplicative_expression.cast_expression.unary_expression.postfix_expression.primary_expression
		if(rightType.constant != null){
			//Validar quando declaração é com uma constant
			//int a = 3;
			checkDeclarationWithConstant(leftType, rightType);
		}else if (rightType.identifier != null && !rightType.identifier.trim.isEmpty()){
			if((variables.containsKey(rightType.identifier) || functions.containsKey(rightType.identifier)) && getExpType(decl.init_declarator_list.get(0).init_declarator.initializer.assignment_expression) == null){
				if(variables.containsKey(rightType.identifier)){
					//Se for um id...
					var varType = variables.get(rightType.identifier);
					if(varType != leftType){
						error("Tipos não compatíveis",
							MyDslPackage.Literals.DECLARATION__INIT_DECLARATOR_LIST
						)
					}
				}else if(functions.containsKey(rightType.identifier)){
					//Se for uma função
					var retType = functions.get(rightType.identifier).retType;
					if(retType != leftType){
						error("Retorno de função não compativel com tipo de variavel",
							MyDslPackage.Literals.DECLARATION__INIT_DECLARATOR_LIST
						)
					}
				}
				var rType = variables.get(rightType.identifier);
				if(leftType == 'enum' && rightType!='enum'){
					error("A variavel deve ser um enum",
						MyDslPackage.Literals.DECLARATION__INIT_DECLARATOR_LIST
					)
				}				
			}else{
			}
			//Validar quando é declaração que inicia com um id
			// int a = b;
		}else if (rightType.expression != null){
			//Validar quando é declaração com uma expressão
			//int a = b+c;
		}

	}
	def static getExpType(assignment_expression exp){
		var current = exp.conditional_expression;
		if(current.conditional_expression_linha != null){
			return ExpRetType.BOOL;
		}
		var current2 = current.logical_or_expression;
		if(current2.logical_or_expression_linha != null){
			return ExpRetType.BOOL;
		}
		var current3 = current2.logical_and_expression;
		if(current3.logical_and_expression_linha != null){
			return ExpRetType.BOOL;
		}
		var current4 = current3.inclusive_or_expression;
		if(current4.inclusive_or_expression_linha != null){
			return ExpRetType.BOOL;
		}
		var current5 = current4.exclusive_or_expression;
		if(current5.exclusive_or_expression_linha != null){
			return ExpRetType.BOOL;
		}
		var current6 = current5.and_expression;
		if(current6.and_expression_linha != null){
			return ExpRetType.BOOL;
		}
		var current7 = current6.equality_expression;
		if(current7.equality_expression_linha != null){
			return ExpRetType.BOOL;
		}
		var current8 = current7.relational_expression;
		if(current8.relational_expression_linha != null){
			return ExpRetType.BOOL;
		}
		var current9 = current8.shift_expression;
		if(current9.shift_expression_linha != null){
			return ExpRetType.NUMERIC;
		}
		var current10 = current9.additive_expression;
		if(current10.additive_expression_linha != null){
			println("MAIS1: " + current10.additive_expression_linha.additive_expression_complement.mais);
			println("MENOS1: " + current10.additive_expression_linha.additive_expression_complement.menos);
			return ExpRetType.NUMERIC;
		}
		var curent11 = current10.multiplicative_expression;
		if(curent11.multiplicative_expression_linha != null){
			return ExpRetType.NUMERIC;
		}
		
		return null;		
	}
	
	@Check
    def checkBlockItemList(block_item_list item){
        if(item.block_item_list_linha.isEmpty()){
            //função de uma linha
            //Final na função
            var current = item.eContainer();
            while(current != null && !(current instanceof function_definition || current instanceof selection_statement)){
                current = current.eContainer();
            }
            if(current instanceof function_definition){
                println("Achou funcao...");
                var func = current as function_definition;
                var retType = func.declaration_specifiers.get(0).type_specifier.type_name_str;
                if(retType != "void"){
                    if(item.block_item.statement == null || item.block_item.statement.jump_statement == null
                        || item.block_item.statement.jump_statement.expression == null
                    ){
                        error("Falta o return", null);
                    }
                }
            }
        }    
    }
    
    @Check
    def checkBlockItemListLinha(block_item_list_linha item){
        println("Sem instancia...");
        if(item.block_item_list_linha.isEmpty()){
            println("Iniciando checagem...");
            var current = item.eContainer();
            while(current != null && !(current instanceof function_definition || current instanceof selection_statement)){
                current = current.eContainer();
            }
            println("Achou funcao...");
            if(current instanceof function_definition){
                println("Achou funcao2...");
                var func = current as function_definition;
                var retType = func.declaration_specifiers.get(0).type_specifier.type_name_str;
                if(retType != "void"){
                    if((item.block_item.statement == null || item.block_item.statement.jump_statement == null
                        || item.block_item.statement.jump_statement.expression == null)
                    ){
                        error("Falta o return", null);
                    }
                }
            }
            //Final na função
        }    
    }
    
    def primaryExpFromAssigExp(assignment_expression exp){
		var ret = exp.conditional_expression.
		logical_or_expression.logical_and_expression.inclusive_or_expression.exclusive_or_expression.
		and_expression.equality_expression.relational_expression.shift_expression.additive_expression.
		multiplicative_expression.cast_expression.unary_expression.postfix_expression.primary_expression;
		return ret;
	}
	
    @Check
	def checkFunctionCall(postfix_expression_complement call){
		var parent = call.eContainer().eContainer() as postfix_expression;
		var name = parent.primary_expression.identifier;
		if(!functions.containsKey(name)){
			error("Função não definida",
				null
			)
		}else{
			var func = functions.get(name);
			println("Checking params for: " + func.name + " With: " + func.params_types.size() + " params.")
			if(func.param_number != call.argument_expression_list.assignment_expressions.size()){
				error("Numero de parametros incompativeis",
					MyDslPackage.Literals.POSTFIX_EXPRESSION_COMPLEMENT__ARGUMENT_EXPRESSION_LIST
				)
			}else{
				for(var i = 0; i < call.argument_expression_list.assignment_expressions.size(); i++){
					var arg = call.argument_expression_list.assignment_expressions.get(i);
					println("Size: " + call.argument_expression_list.assignment_expressions.size());
					println("For: " + i);
					var argType = func.params_types.get(i);
					if(getExpType(arg) != null){
						println("Is an expression");
						var expRet = getExpType(arg);
						if(expRet == ExpRetType.NUMERIC){
							if(argType == 'bool'){
								error("Tipo de parametro não compativel",
									MyDslPackage.Literals.POSTFIX_EXPRESSION_COMPLEMENT__ARGUMENT_EXPRESSION_LIST
								)
							}
						}else if(expRet == ExpRetType.BOOL){
							if(argType != 'bool'){
								error("Tipo de parametro não compativel",
									MyDslPackage.Literals.POSTFIX_EXPRESSION_COMPLEMENT__ARGUMENT_EXPRESSION_LIST
								)
							}
						}
					}else{
						println("Is an contant or id")
						var idOrCons = primaryExpFromAssigExp(arg);
						println("CP1");
						if(idOrCons.identifier != null && !idOrCons.identifier.trim().isEmpty()){
							println("CP2");
							if(variables.containsKey(idOrCons.identifier)){
								//é UMA VARIAAVEL
								if(variables.get(idOrCons.identifier) != argType){
									println("CP3");
									error("Tipo de parametro não compativel",
										MyDslPackage.Literals.POSTFIX_EXPRESSION_COMPLEMENT__ARGUMENT_EXPRESSION_LIST
									)
								}
							}else if( functions.containsKey(idOrCons.identifier)){
								if(functions.get(idOrCons.identifier).retType != argType){
									error("Tipo de parametro não compativel",
										MyDslPackage.Literals.POSTFIX_EXPRESSION_COMPLEMENT__ARGUMENT_EXPRESSION_LIST
									)
								}
							}
						}
						println("CP4");
						if(idOrCons.constant != null && idOrCons.constant.char != null && argType != 'char'){
							println("CP5");
							error("Tipo de parametro não com 	pativel",
									MyDslPackage.Literals.POSTFIX_EXPRESSION_COMPLEMENT__ARGUMENT_EXPRESSION_LIST
							)
						}
						println("CP7");
						//O argumento é uma contante ou um id
					}
					println("End of iteration");
					//Validating params
					//call.argument_expression_list.get(i)
				}
				println("For ended");
			}
		}
		
	}
	
	@Check
	def checkForEmptyParamFunc(PostFixEmpryParams call){
		var parent = call.eContainer().eContainer() as postfix_expression;
		var name = parent.primary_expression.identifier;
		if(!functions.containsKey(name)){
			error("Função não definida",
				null
			)
		}else{
			var func = functions.get(name);
			if(func.param_number != 0){
				error("Numero de parametros incompativeis",
					null
				)
			}
		}
	}
	
	@Check
	def validateFunctionReturn(jump_statement ret){
		if(ret.expression != null){
			var current = ret.eContainer();
            while(current != null && !(current instanceof function_definition)){
                current = current.eContainer();
            }
            if(current instanceof function_definition){
                var func = current as function_definition;
                var argType = func.declaration_specifiers.get(0).type_specifier.type_name_str;
                if(argType != "void"){
                	var arg = ret.expression.assignment_expression;
                	if(getExpType(arg) != null){
						var expRet = getExpType(arg);
						if(expRet == ExpRetType.NUMERIC){
							if(argType == 'bool'){
								error("Tipo de parametro não compativel",
									null
								)
							}
						}else if(expRet == ExpRetType.BOOL){
							if(argType != 'bool'){
								error("Tipo de parametro não compativel",
									null
								)
							}
						}
					}else{
						println("Is an contant or id")
						var idOrCons = primaryExpFromAssigExp(arg);
						if(idOrCons.identifier != null && !idOrCons.identifier.trim().isEmpty()){
							if(variables.containsKey(idOrCons.identifier)){
								//é UMA VARIAAVEL
								if(variables.get(idOrCons.identifier) != argType){
									error("Retorno não compatível",
										null
									)
								}
							}else if( functions.containsKey(idOrCons.identifier)){
								if(functions.get(idOrCons.identifier).retType != argType){
									error("Retorno não compatível",
										null
									)
								}
							}
						}
						if(idOrCons.constant != null && idOrCons.constant.char != null && argType != 'char'){
							error("Retorno não compatível",
									null
							)
						}
						//O argumento é uma contante ou um id
					}
                }
            }
		}
	}
	
	@Check
	def checkFunctionDefinition(function_definition func_decl){
		//Não tem parametros
		var f = new Function();		
		if(func_decl.declarator.direct_declarator.direct_declarator_linha.direct_declarator_complemento == null){
			f.retType = func_decl.declaration_specifiers.get(0).type_specifier.type_name_str;
			f.name = func_decl.declarator.direct_declarator.identifier.toString();
			f.param_number = 0;
			println("Inserting function... " + f.name + "With 0 params");
			functions.put(f.name, f);
		}else{
			f.retType = func_decl.declaration_specifiers.get(0).type_specifier.type_name_str;
			f.name = func_decl.declarator.direct_declarator.identifier.toString();
			var params = func_decl.declarator.direct_declarator.direct_declarator_linha.direct_declarator_complemento.parameter_type_list.parameter_lista.parameter_declarations;
			f.param_number = params.size;		
			for(var i = 0; i< f.param_number; i++){
				var decl = params.get(i);
				f.params_types.add(decl.declaration_specifiers.type_specifier.type_name_str);
				
				variables.put(decl.declarator.direct_declarator.identifier, decl.declaration_specifiers.type_specifier.type_name_str);
			}
			println("Inserting function... " + f.name + "with " + f.param_number + " params");
			functions.put(f.name, f);
			//println( "size:" + func_decl.declarator.direct_declarator.direct_declarator_linha.direct_declarator_complemento.parameter_type_list.parameter_list.get(0));
		}
	}
	
	@Check
	def checkAtribType(assignment_expression asexp){		
		var idLeft = asexp.unary_expression.postfix_expression.primary_expression.identifier;
		var argType = variables.get(idLeft);
		if(!variables.keySet.contains(idLeft)){
			error('Variavel não declarada',
				MyDslPackage.Literals.ASSIGNMENT_EXPRESSION__UNARY_EXPRESSION
			);
		}
		if(asexp.assignment_expression != null && getExpType(asexp.assignment_expression) != null){
			var arg = asexp.assignment_expression;
			println("Is an expression");
			var expRet = getExpType(arg);
			if(expRet == ExpRetType.NUMERIC){
				if(argType == 'bool'){
					error("Variavel não compativel com este tipo",
						null
					)
				}
			}else if(expRet == ExpRetType.BOOL){
				if(argType != 'bool'){
					error("Tipo de parametro não compativel",
						null
					)
				}
			}
		}else{
			var idOrCons = primaryExpFromAssigExp(asexp.assignment_expression);
			if(idOrCons.identifier != null && !idOrCons.identifier.trim().isEmpty()){
				if(variables.containsKey(idOrCons.identifier)){
					//é UMA VARIAAVEL
					if(variables.get(idOrCons.identifier) != argType){						
						error("Variavel não compativel com este tipo",
							null
						)
					}
				}else if( functions.containsKey(idOrCons.identifier)){
					if(functions.get(idOrCons.identifier).retType != argType){
						error("Variavel não compativel com este tipo",
							null
						)
					}
				}
			}			
			if(idOrCons.constant != null && idOrCons.constant.char != null && argType != 'char'){				
				error("Variavel não compativel com este tipo",
						null
				)
			}		
			//O argumento é uma contante ou um id
		}
	}
	
	def checkSwitch(selection_statement sel_stmt){
		var id = sel_stmt.expression.assignment_expression.assignment_expression.conditional_expression.
							logical_or_expression.logical_and_expression.inclusive_or_expression.exclusive_or_expression.
							and_expression.equality_expression.relational_expression.shift_expression.additive_expression.
							multiplicative_expression.cast_expression.unary_expression.postfix_expression.primary_expression.identifier;
		if(variables.keySet.contains(id)){
			error("Variavel não declarada", MyDslPackage.Literals.SELECTION_STATEMENT__EXPRESSION);
		}
		sel_stmt.statement.compound_statement;
	}
//	@Check
//	def checkAttributionTypes(attribution) {
//		
//	}
}
